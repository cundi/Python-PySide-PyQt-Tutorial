<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QUdpSocket &mdash; PySide 1.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.2.1 documentation" href="../../index.html" />
    <link rel="up" title="PySide.QtNetwork" href="index.html" />
    <link rel="next" title="QLocalSocket" href="QLocalSocket.html" />
    <link rel="prev" title="QAbstractSocket" href="QAbstractSocket.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.2.1 documentation</a></li>
                <li> &raquo; <a href="../../modules.html" >PySide modules</a></li>
                <li> &raquo; <a href="index.html" accesskey="U">PySide.QtNetwork</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QUdpSocket</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a><ul>
<li><a class="reference internal" href="#symbian-platform-security-requirements">Symbian Platform Security Requirements</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QAbstractSocket.html"
                        title="previous chapter">QAbstractSocket</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QLocalSocket.html"
                        title="next chapter">QLocalSocket</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtNetwork"></span><div class="section" id="qudpsocket">
<span id="id1"></span><h1>QUdpSocket<a class="headerlink" href="#qudpsocket" title="Permalink to this headline">¶</a></h1>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">bind</span></tt></a> ([port=0])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">bind</span></tt></a> (address, port)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">bind</span></tt></a> (address, port, mode)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">bind</span></tt></a> (port, mode)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams"><tt class="xref py py-meth docutils literal"><span class="pre">hasPendingDatagrams</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">joinMulticastGroup</span></tt></a> (groupAddress)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">joinMulticastGroup</span></tt></a> (groupAddress, iface)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">leaveMulticastGroup</span></tt></a> (groupAddress)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">leaveMulticastGroup</span></tt></a> (groupAddress, iface)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface"><tt class="xref py py-meth docutils literal"><span class="pre">multicastInterface</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize"><tt class="xref py py-meth docutils literal"><span class="pre">pendingDatagramSize</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">readDatagram</span></tt></a> (, maxlen)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface"><tt class="xref py py-meth docutils literal"><span class="pre">setMulticastInterface</span></tt></a> (iface)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">writeDatagram</span></tt></a> (datagram, host, port)</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> class provides a UDP socket.</p>
<p>UDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability isn&#8217;t important. <a class="reference internal" href="#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> is a subclass of <a class="reference internal" href="QAbstractSocket.html#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> that allows you to send and receive UDP datagrams.</p>
<p>The most common way to use this class is to bind to an address and port using <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.bind()</span></tt></a> , then call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.writeDatagram()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.readDatagram()</span></tt></a> to transfer data. If you want to use the standard <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> functions <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt> , <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt> , <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt> , etc., you must first connect the socket directly to a peer by calling <a class="reference internal" href="QAbstractSocket.html#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> .</p>
<p>The socket emits the <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesWritten()</span></tt> signal every time a datagram is written to the network. If you just want to send datagrams, you don&#8217;t need to call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.bind()</span></tt></a> .</p>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt> signal is emitted whenever datagrams arrive. In that case, <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.hasPendingDatagrams()</span></tt></a> returns true. Call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.pendingDatagramSize()</span></tt></a> to obtain the size of the first pending datagram, and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.readDatagram()</span></tt></a> to read it.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An incoming datagram should be read when you receive the <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt> signal, otherwise this signal will not be emitted for the next datagram.</p>
</div>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">initSocket</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">udpSocket</span> <span class="o">=</span> <span class="n">QUdpSocket</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">udpSocket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">QHostAddress</span><span class="o">.</span><span class="n">LocalHost</span><span class="p">,</span> <span class="mi">7755</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">udpSocket</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s">&#39;readyRead()&#39;</span><span class="p">),</span>
                 <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s">&#39;readPendingDatagrams()&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">readPendingDatagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">udpSocket</span><span class="o">.</span><span class="n">hasPendingDatagrams</span><span class="p">():</span>
        <span class="n">datagram</span> <span class="o">=</span> <span class="n">QByteArray</span><span class="p">()</span>
        <span class="n">datagram</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">udpSocket</span><span class="o">.</span><span class="n">pendingDatagramSize</span><span class="p">())</span>

        <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">senderPort</span><span class="p">)</span> <span class="o">=</span> <span class="n">udpSocket</span><span class="o">.</span><span class="n">readDatagram</span><span class="p">(</span><span class="n">datagram</span><span class="o">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">datagram</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>

        <span class="n">processTheDatagram</span><span class="p">(</span><span class="n">datagram</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> also supports UDP multicast. Use <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.joinMulticastGroup()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.leaveMulticastGroup()</span></tt></a> to control group membership, and <tt class="xref py py-attr docutils literal"><span class="pre">QAbstractSocket.MulticastTtlOption</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">QAbstractSocket.MulticastLoopbackOption</span></tt> to set the TTL and loopback socket options. Use <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.setMulticastInterface()</span></tt></a> to control the outgoing interface for multicast datagrams, and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.multicastInterface()</span></tt></a> to query it.</p>
<p>With <a class="reference internal" href="#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> , you can also establish a virtual connection to a UDP server using <a class="reference internal" href="QAbstractSocket.html#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> and then use <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt> to exchange datagrams without specifying the receiver for each datagram.</p>
<p>The <em class="xref std std-ref">Broadcast Sender</em> , <em class="xref std std-ref">Broadcast Receiver</em> , <em class="xref std std-ref">Multicast Sender</em> , and <em class="xref std std-ref">Multicast Receiver</em> examples illustrate how to use <a class="reference internal" href="#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> in applications.</p>
</div></blockquote>
<div class="section" id="symbian-platform-security-requirements">
<span id="pyside-qtnetwork-qudpsocket-symbian-platform-security-requirements"></span><h3>Symbian Platform Security Requirements<a class="headerlink" href="#symbian-platform-security-requirements" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>On Symbian, processes which use this class must have the <tt class="docutils literal"><span class="pre">NetworkServices</span></tt> platform security capability. If the client process lacks this capability, operations will result in a panic.</p>
<p>Platform security capabilities are added via the <em class="xref std std-ref">TARGET.CAPABILITY</em> qmake variable.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide.QtNetwork.QUdpSocket">
<em class="property">class </em><tt class="descclassname">PySide.QtNetwork.</tt><tt class="descname">QUdpSocket</tt><big>(</big><span class="optional">[</span><em>parent=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.QUdpSocket" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parent</strong> &#8211; <a class="reference internal" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="PySide.QtCore.QObject"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QObject</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Creates a <a class="reference internal" href="#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> object.</p>
<p><tt class="docutils literal"><span class="pre">parent</span></tt> is passed to the <a class="reference internal" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="PySide.QtCore.QObject"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QObject</span></tt></a> constructor.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QAbstractSocket.html#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.socketType()</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.BindFlag">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">BindFlag</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.BindFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the different flags you can pass to modify the behavior of <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">QUdpSocket.bind()</span></tt></a> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On Symbian OS bind flags behaviour depends on process capabilties. If process has NetworkControl capability, the bind attempt with <tt class="xref py py-attr docutils literal"><span class="pre">ReuseAddressHint</span></tt> will always succeed even if the address and port is already bound by another socket with any flags. If process does not have NetworkControl capability, the bind attempt to address and port already bound by another socket will always fail.</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QUdpSocket.ShareAddress</td>
<td>Allow other services to bind to the same address and port. This is useful when multiple processes share the load of a single service by listening to the same address and port (e.g., a web server with several pre-forked listeners can greatly improve response time). However, because any service is allowed to rebind, this option is subject to certain security considerations. Note that by combining this option with <tt class="xref py py-attr docutils literal"><span class="pre">ReuseAddressHint</span></tt> , you will also allow your service to rebind an existing shared address. On Unix, this is equivalent to the SO_REUSEADDR socket option. On Windows, this option is ignored.</td>
</tr>
<tr class="row-odd"><td>QUdpSocket.DontShareAddress</td>
<td>Bind the address and port exclusively, so that no other services are allowed to rebind. By passing this option to <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">QUdpSocket.bind()</span></tt></a> , you are guaranteed that on successs, your service is the only one that listens to the address and port. No services are allowed to rebind, even if they pass <tt class="xref py py-attr docutils literal"><span class="pre">ReuseAddressHint</span></tt> . This option provides more security than <tt class="xref py py-attr docutils literal"><span class="pre">ShareAddress</span></tt> , but on certain operating systems, it requires you to run the server with administrator privileges. On Unix and Mac OS X, not sharing is the default behavior for binding an address and port, so this option is ignored. On Windows, this option uses the SO_EXCLUSIVEADDRUSE socket option.</td>
</tr>
<tr class="row-even"><td>QUdpSocket.ReuseAddressHint</td>
<td>Provides a hint to <a class="reference internal" href="#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> that it should try to rebind the service even if the address and port are already bound by another socket. On Windows, this is equivalent to the SO_REUSEADDR socket option. On Unix, this option is ignored.</td>
</tr>
<tr class="row-odd"><td>QUdpSocket.DefaultForPlatform</td>
<td>The default option for the current platform. On Unix and Mac OS X, this is equivalent to ( <tt class="xref py py-attr docutils literal"><span class="pre">DontShareAddress</span></tt> + <tt class="xref py py-attr docutils literal"><span class="pre">ReuseAddressHint</span></tt> ), and on Windows, its equivalent to <tt class="xref py py-attr docutils literal"><span class="pre">ShareAddress</span></tt> .</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">bind</tt><big>(</big><span class="optional">[</span><em>port=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Binds to <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a> :Any on port <tt class="docutils literal"><span class="pre">port</span></tt> .</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">bind</tt><big>(</big><em>port</em>, <em>mode</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
<li><strong>mode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.BindMode</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">bind</tt><big>(</big><em>address</em>, <em>port</em>, <em>mode</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>address</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
<li><strong>mode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.BindMode</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">bind</tt><big>(</big><em>address</em>, <em>port</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>address</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Binds this socket to the address <tt class="docutils literal"><span class="pre">address</span></tt> and the port <tt class="docutils literal"><span class="pre">port</span></tt> . When bound, the signal <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt> is emitted whenever a UDP datagram arrives on the specified address and port. This function is useful to write UDP servers.</p>
<p>On success, the functions returns true and the socket enters <tt class="xref py py-attr docutils literal"><span class="pre">BoundState</span></tt> ; otherwise it returns false.</p>
<p>The socket is bound using the <tt class="xref py py-attr docutils literal"><span class="pre">DefaultForPlatform</span></tt> <tt class="xref py py-class docutils literal"><span class="pre">BindMode</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.readDatagram()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">hasPendingDatagrams</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if at least one datagram is waiting to be read; otherwise returns false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.pendingDatagramSize()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.readDatagram()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">joinMulticastGroup</tt><big>(</big><em>groupAddress</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>groupAddress</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Joins the the multicast group specified by <tt class="docutils literal"><span class="pre">groupAddress</span></tt> on the default interface chosen by the operating system. The socket must be in <tt class="xref py py-attr docutils literal"><span class="pre">BoundState</span></tt> , otherwise an error occurs.</p>
<p>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.leaveMulticastGroup()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">joinMulticastGroup</tt><big>(</big><em>groupAddress</em>, <em>iface</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>groupAddress</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></li>
<li><strong>iface</strong> &#8211; <a class="reference internal" href="QNetworkInterface.html#PySide.QtNetwork.QNetworkInterface" title="PySide.QtNetwork.QNetworkInterface"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkInterface</span></tt></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Joins the multicast group address <tt class="docutils literal"><span class="pre">groupAddress</span></tt> on the interface <tt class="docutils literal"><span class="pre">iface</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.leaveMulticastGroup()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">leaveMulticastGroup</tt><big>(</big><em>groupAddress</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>groupAddress</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Leaves the multicast group specified by <tt class="docutils literal"><span class="pre">groupAddress</span></tt> on the default interface chosen by the operating system. The socket must be in <tt class="xref py py-attr docutils literal"><span class="pre">BoundState</span></tt> , otherwise an error occurs.</p>
<p>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.joinMulticastGroup()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">leaveMulticastGroup</tt><big>(</big><em>groupAddress</em>, <em>iface</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>groupAddress</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></li>
<li><strong>iface</strong> &#8211; <a class="reference internal" href="QNetworkInterface.html#PySide.QtNetwork.QNetworkInterface" title="PySide.QtNetwork.QNetworkInterface"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkInterface</span></tt></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Leaves the multicast group specified by <tt class="docutils literal"><span class="pre">groupAddress</span></tt> on the interface <tt class="docutils literal"><span class="pre">iface</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.joinMulticastGroup()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">multicastInterface</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QNetworkInterface.html#PySide.QtNetwork.QNetworkInterface" title="PySide.QtNetwork.QNetworkInterface"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkInterface</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the interface for the outgoing interface for multicast datagrams. This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. If no interface has been previously set, this function returns an invalid <a class="reference internal" href="QNetworkInterface.html#PySide.QtNetwork.QNetworkInterface" title="PySide.QtNetwork.QNetworkInterface"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkInterface</span></tt></a> . The socket must be in <tt class="xref py py-attr docutils literal"><span class="pre">BoundState</span></tt> , otherwise an invalid <a class="reference internal" href="QNetworkInterface.html#PySide.QtNetwork.QNetworkInterface" title="PySide.QtNetwork.QNetworkInterface"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkInterface</span></tt></a> is returned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.setMulticastInterface()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">pendingDatagramSize</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the size of the first pending UDP datagram. If there is no datagram available, this function returns -1.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.hasPendingDatagrams()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.readDatagram()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">readDatagram</tt><big>(</big><em>maxlen</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.readDatagram" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxlen</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(data, address, port)</td>
</tr>
</tbody>
</table>
<p>Receives a datagram no larger than <tt class="docutils literal"><span class="pre">maxSize</span></tt> bytes and stores it in <tt class="docutils literal"><span class="pre">data</span></tt> . The sender&#8217;s host address and port is stored in *``address`` and *``port`` (unless the pointers are 0).</p>
<p>Returns the size of the datagram on success; otherwise returns -1.</p>
<p>If <tt class="docutils literal"><span class="pre">maxSize</span></tt> is too small, the rest of the datagram will be lost. To avoid loss of data, call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.pendingDatagramSize()</span></tt></a> to determine the size of the pending datagram before attempting to read it. If <tt class="docutils literal"><span class="pre">maxSize</span></tt> is 0, the datagram will be discarded.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.writeDatagram()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.hasPendingDatagrams"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.hasPendingDatagrams()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.pendingDatagramSize"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.pendingDatagramSize()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">setMulticastInterface</tt><big>(</big><em>iface</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.setMulticastInterface" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>iface</strong> &#8211; <a class="reference internal" href="QNetworkInterface.html#PySide.QtNetwork.QNetworkInterface" title="PySide.QtNetwork.QNetworkInterface"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkInterface</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the outgoing interface for multicast datagrams to the interface <tt class="docutils literal"><span class="pre">iface</span></tt> . This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. The socket must be in <tt class="xref py py-attr docutils literal"><span class="pre">BoundState</span></tt> , otherwise this function does nothing.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.multicastInterface"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.multicastInterface()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.joinMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.joinMulticastGroup()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.leaveMulticastGroup"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket.leaveMulticastGroup()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram">
<tt class="descclassname">PySide.QtNetwork.QUdpSocket.</tt><tt class="descname">writeDatagram</tt><big>(</big><em>datagram</em>, <em>host</em>, <em>port</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.writeDatagram" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datagram</strong> &#8211; <a class="reference internal" href="../QtCore/QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></li>
<li><strong>host</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Sends the datagram <tt class="docutils literal"><span class="pre">datagram</span></tt> to the host address <tt class="docutils literal"><span class="pre">host</span></tt> and at port <tt class="docutils literal"><span class="pre">port</span></tt> .</p>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>