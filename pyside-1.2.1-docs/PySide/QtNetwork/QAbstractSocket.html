<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QAbstractSocket &mdash; PySide 1.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.2.1 documentation" href="../../index.html" />
    <link rel="up" title="PySide.QtNetwork" href="index.html" />
    <link rel="next" title="QUdpSocket" href="QUdpSocket.html" />
    <link rel="prev" title="QNetworkReply" href="QNetworkReply.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.2.1 documentation</a></li>
                <li> &raquo; <a href="../../modules.html" >PySide modules</a></li>
                <li> &raquo; <a href="index.html" accesskey="U">PySide.QtNetwork</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QAbstractSocket</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#slots">Slots</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QNetworkReply.html"
                        title="previous chapter">QNetworkReply</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QUdpSocket.html"
                        title="next chapter">QUdpSocket</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtNetwork"></span><div class="section" id="qabstractsocket">
<span id="id1"></span><h1>QAbstractSocket<a class="headerlink" href="#qabstractsocket" title="Permalink to this headline">¶</a></h1>
<p><strong>Inherited by:</strong> <a class="reference internal" href="QUdpSocket.html#qudpsocket"><em>QUdpSocket</em></a>, <a class="reference internal" href="QTcpSocket.html#qtcpsocket"><em>QTcpSocket</em></a>, <a class="reference internal" href="QSslSocket.html#qsslsocket"><em>QSslSocket</em></a></p>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.abort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.abort"><tt class="xref py py-meth docutils literal"><span class="pre">abort</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">connectToHost</span></tt></a> (address, port[, mode=QIODevice.ReadWrite])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">connectToHost</span></tt></a> (hostName, port[, mode=QIODevice.ReadWrite])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost"><tt class="xref py py-meth docutils literal"><span class="pre">disconnectFromHost</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error"><tt class="xref py py-meth docutils literal"><span class="pre">error</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.flush" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.flush"><tt class="xref py py-meth docutils literal"><span class="pre">flush</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.isValid" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">isValid</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress"><tt class="xref py py-meth docutils literal"><span class="pre">localAddress</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort"><tt class="xref py py-meth docutils literal"><span class="pre">localPort</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">peerAddress</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName"><tt class="xref py py-meth docutils literal"><span class="pre">peerName</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort"><tt class="xref py py-meth docutils literal"><span class="pre">peerPort</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxy" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxy"><tt class="xref py py-meth docutils literal"><span class="pre">proxy</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.readBufferSize" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.readBufferSize"><tt class="xref py py-meth docutils literal"><span class="pre">readBufferSize</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress"><tt class="xref py py-meth docutils literal"><span class="pre">setLocalAddress</span></tt></a> (address)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort"><tt class="xref py py-meth docutils literal"><span class="pre">setLocalPort</span></tt></a> (port)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">setPeerAddress</span></tt></a> (address)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerName" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerName"><tt class="xref py py-meth docutils literal"><span class="pre">setPeerName</span></tt></a> (name)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort"><tt class="xref py py-meth docutils literal"><span class="pre">setPeerPort</span></tt></a> (port)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy"><tt class="xref py py-meth docutils literal"><span class="pre">setProxy</span></tt></a> (networkProxy)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize"><tt class="xref py py-meth docutils literal"><span class="pre">setReadBufferSize</span></tt></a> (size)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor"><tt class="xref py py-meth docutils literal"><span class="pre">setSocketDescriptor</span></tt></a> (socketDescriptor[, state=ConnectedState[, openMode=QIODevice.ReadWrite]])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketError" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketError"><tt class="xref py py-meth docutils literal"><span class="pre">setSocketError</span></tt></a> (socketError)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketOption" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketOption"><tt class="xref py py-meth docutils literal"><span class="pre">setSocketOption</span></tt></a> (option, value)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketState" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketState"><tt class="xref py py-meth docutils literal"><span class="pre">setSocketState</span></tt></a> (state)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketDescriptor" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketDescriptor"><tt class="xref py py-meth docutils literal"><span class="pre">socketDescriptor</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketOption" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketOption"><tt class="xref py py-meth docutils literal"><span class="pre">socketOption</span></tt></a> (option)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType"><tt class="xref py py-meth docutils literal"><span class="pre">socketType</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state"><tt class="xref py py-meth docutils literal"><span class="pre">state</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForConnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForConnected"><tt class="xref py py-meth docutils literal"><span class="pre">waitForConnected</span></tt></a> ([msecs=30000])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForDisconnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForDisconnected"><tt class="xref py py-meth docutils literal"><span class="pre">waitForDisconnected</span></tt></a> ([msecs=30000])</li>
</ul>
</div>
<div class="section" id="slots">
<h3>Slots<a class="headerlink" href="#slots" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHostImplementation" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHostImplementation"><tt class="xref py py-meth docutils literal"><span class="pre">connectToHostImplementation</span></tt></a> (hostName, port[, mode=QIODevice.ReadWrite])</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHostImplementation" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHostImplementation"><tt class="xref py py-meth docutils literal"><span class="pre">disconnectFromHostImplementation</span></tt></a> ()</li>
</ul>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected"><tt class="xref py py-meth docutils literal"><span class="pre">connected</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected"><tt class="xref py py-meth docutils literal"><span class="pre">disconnected</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error"><tt class="xref py py-meth docutils literal"><span class="pre">error</span></tt></a> (arg__1)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.hostFound" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.hostFound"><tt class="xref py py-meth docutils literal"><span class="pre">hostFound</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxyAuthenticationRequired" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxyAuthenticationRequired"><tt class="xref py py-meth docutils literal"><span class="pre">proxyAuthenticationRequired</span></tt></a> (proxy, authenticator)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">stateChanged</span></tt></a> (arg__1)</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> class provides the base functionality common to all socket types.</p>
<p><a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> is the base class for <a class="reference internal" href="QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> and <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> and contains all common functionality of these two classes. If you need a socket, you have two options:</p>
<ul class="simple">
<li>Instantiate <a class="reference internal" href="QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> or <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> .</li>
<li>Create a native socket descriptor, instantiate <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> , and call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setSocketDescriptor()</span></tt></a> to wrap the native socket.</li>
</ul>
<p>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. UDP (User Datagram Protocol) is an unreliable, datagram-oriented, connectionless protocol. In practice, this means that TCP is better suited for continuous transmission of data, whereas the more lightweight UDP can be used when reliability isn&#8217;t important.</p>
<p><a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> &#8216;s API unifies most of the differences between the two protocols. For example, although UDP is connectionless, <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> establishes a virtual connection for UDP sockets, enabling you to use <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> in more or less the same way regardless of the underlying protocol. Internally, <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> remembers the address and port passed to <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> , and functions like <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt> use these values.</p>
<p>At any time, <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> has a state (returned by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.state()</span></tt></a> ). The initial state is <tt class="xref py py-attr docutils literal"><span class="pre">UnconnectedState</span></tt> . After calling <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> , the socket first enters <tt class="xref py py-attr docutils literal"><span class="pre">HostLookupState</span></tt> . If the host is found, <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> enters <tt class="xref py py-attr docutils literal"><span class="pre">ConnectingState</span></tt> and emits the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.hostFound" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.hostFound"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.hostFound()</span></tt></a> signal. When the connection has been established, it enters <tt class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></tt> and emits <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connected()</span></tt></a> . If an error occurs at any stage, <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.error()</span></tt></a> is emitted. Whenever the state changes, <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.stateChanged" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.stateChanged"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.stateChanged()</span></tt></a> is emitted. For convenience, <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.isValid" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.isValid()</span></tt></a> returns true if the socket is ready for reading and writing, but note that the socket&#8217;s state must be <tt class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></tt> before reading and writing can occur.</p>
<p>Read or write data by calling <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt> , or use the convenience functions <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readAll()</span></tt> . <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> also inherits <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.getChar()</span></tt> , <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.putChar()</span></tt> , and <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.ungetChar()</span></tt> from <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> , which work on single bytes. The <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesWritten()</span></tt> signal is emitted when data has been written to the socket (i.e., when the client has read the data). Note that Qt does not limit the write buffer size. You can monitor its size by listening to this signal.</p>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt> signal is emitted every time a new chunk of data has arrived. <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.bytesAvailable()</span></tt> then returns the number of bytes that are available for reading. Typically, you would connect the <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt> signal to a slot and read all available data there. If you don&#8217;t read all the data at once, the remaining data will still be available later, and any new incoming data will be appended to <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> &#8216;s internal read buffer. To limit the size of the read buffer, call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setReadBufferSize()</span></tt></a> .</p>
<p>To close the socket, call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnectFromHost()</span></tt></a> . <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> enters <tt class="xref py py-attr docutils literal"><span class="pre">QAbstractSocket.ClosingState</span></tt> . After all pending data has been written to the socket, <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> actually closes the socket, enters QAbstractSocket::ClosedState, and emits <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnected()</span></tt></a> . If you want to abort a connection immediately, discarding all pending data, call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.abort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.abort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.abort()</span></tt></a> instead. If the remote host closes the connection, <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> will emit error( <tt class="xref py py-attr docutils literal"><span class="pre">QAbstractSocket.RemoteHostClosedError</span></tt> ), during which the socket state will still be <tt class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></tt> , and then the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnected()</span></tt></a> signal will be emitted.</p>
<p>The port and address of the connected peer is fetched by calling <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerPort()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerAddress()</span></tt></a> . <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerName()</span></tt></a> returns the host name of the peer, as passed to <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> . <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localPort()</span></tt></a> and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localAddress()</span></tt></a> return the port and address of the local socket.</p>
<p><a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> provides a set of functions that suspend the calling thread until certain signals are emitted. These functions can be used to implement blocking sockets:</p>
<ul class="simple">
<li><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForConnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForConnected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.waitForConnected()</span></tt></a> blocks until a connection has been established.</li>
<li><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.waitForReadyRead()</span></tt> blocks until new data is available for reading.</li>
<li><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.waitForBytesWritten()</span></tt> blocks until one payload of data has been written to the socket.</li>
<li><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForDisconnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForDisconnected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.waitForDisconnected()</span></tt></a> blocks until the connection has closed.</li>
</ul>
<p>We show an example:</p>
<div class="highlight-python"><pre>numRead = 0
numReadTotal = 0

while(True):
    buffer  = socket.read(50)
    # do whatever with array
    numReadTotal += buffer.size()
    if (buffer.size() == 0 &amp;&amp; !socket.waitForReadyRead()):
        break</pre>
</div>
<p>If <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.waitForReadyRead()</span></tt> returns false, the connection has been closed or an error has occurred.</p>
<p>Programming with a blocking socket is radically different from programming with a non-blocking socket. A blocking socket doesn&#8217;t require an event loop and typically leads to simpler code. However, in a GUI application, blocking sockets should only be used in non-GUI threads, to avoid freezing the user interface. See the <em class="xref std std-ref">network/fortuneclient</em> and <em class="xref std std-ref">network/blockingfortuneclient</em> examples for an overview of both approaches.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We discourage the use of the blocking functions together with signals. One of the two possibilities should be used.</p>
</div>
<p><a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> can be used with <a class="reference internal" href="../QtCore/QTextStream.html#PySide.QtCore.QTextStream" title="PySide.QtCore.QTextStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QTextStream</span></tt></a> and <a class="reference internal" href="../QtCore/QDataStream.html#PySide.QtCore.QDataStream" title="PySide.QtCore.QDataStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QDataStream</span></tt></a> &#8216;s stream operators (operator&lt;&lt;() and operator&gt;&gt;()). There is one issue to be aware of, though: You must make sure that enough data is available before attempting to read it using operator&gt;&gt;().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QFtp.html#PySide.QtNetwork.QFtp" title="PySide.QtNetwork.QFtp"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QFtp</span></tt></a>  <a class="reference internal" href="QNetworkAccessManager.html#PySide.QtNetwork.QNetworkAccessManager" title="PySide.QtNetwork.QNetworkAccessManager"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkAccessManager</span></tt></a>  <a class="reference internal" href="QTcpServer.html#PySide.QtNetwork.QTcpServer" title="PySide.QtNetwork.QTcpServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpServer</span></tt></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide.QtNetwork.QAbstractSocket">
<em class="property">class </em><tt class="descclassname">PySide.QtNetwork.</tt><tt class="descname">QAbstractSocket</tt><big>(</big><em>socketType</em>, <em>parent</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.QAbstractSocket" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>socketType</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketType" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketType"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketType</span></tt></a></li>
<li><strong>parent</strong> &#8211; <a class="reference internal" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="PySide.QtCore.QObject"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QObject</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Creates a new abstract socket of type <tt class="docutils literal"><span class="pre">socketType</span></tt> . The <tt class="docutils literal"><span class="pre">parent</span></tt> argument is passed to <a class="reference internal" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="PySide.QtCore.QObject"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QObject</span></tt></a> &#8216;s constructor.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.socketType()</span></tt></a>  <a class="reference internal" href="QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a>  <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketType">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">SocketType</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketType" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the transport layer protocol.</p>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QAbstractSocket.TcpSocket</td>
<td>TCP</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.UdpSocket</td>
<td>UDP</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.UnknownSocketType</td>
<td>Other than TCP and UDP</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractSocket.socketType()</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">SocketError</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the socket errors that can occur.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QAbstractSocket.ConnectionRefusedError</td>
<td>The connection was refused by the peer (or timed out).</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.RemoteHostClosedError</td>
<td>The remote host closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.HostNotFoundError</td>
<td>The host address was not found.</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.SocketAccessError</td>
<td>The socket operation failed because the application lacked the required privileges.</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.SocketResourceError</td>
<td>The local system ran out of resources (e.g., too many sockets).</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.SocketTimeoutError</td>
<td>The socket operation timed out.</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.DatagramTooLargeError</td>
<td>The datagram was larger than the operating system&#8217;s limit (which can be as low as 8192 bytes).</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.NetworkError</td>
<td>An error occurred with the network (e.g., the network cable was accidentally plugged out).</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.AddressInUseError</td>
<td>The address specified to <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">QUdpSocket.bind()</span></tt></a> is already in use and was set to be exclusive.</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.SocketAddressNotAvailableError</td>
<td>The address specified to <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">QUdpSocket.bind()</span></tt></a> does not belong to the host.</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.UnsupportedSocketOperationError</td>
<td>The requested socket operation is not supported by the local operating system (e.g., lack of IPv6 support).</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.ProxyAuthenticationRequiredError</td>
<td>The socket is using a proxy, and the proxy requires authentication.</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.SslHandshakeFailedError</td>
<td>The SSL/TLS handshake failed, so the connection was closed (only used in <a class="reference internal" href="QSslSocket.html#PySide.QtNetwork.QSslSocket" title="PySide.QtNetwork.QSslSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QSslSocket</span></tt></a> ) (This value was introduced in 4.4.)</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.UnfinishedSocketOperationError</td>
<td>Used by <tt class="xref py py-class docutils literal"><span class="pre">QAbstractSocketEngine</span></tt> only, The last operation attempted has not finished yet (still in progress in the background). (This value was introduced in 4.4.)</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.ProxyConnectionRefusedError</td>
<td>Could not contact the proxy server because the connection to that server was denied (This value was introduced in 4.5.)</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.ProxyConnectionClosedError</td>
<td>The connection to the proxy server was closed unexpectedly (before the connection to the final peer was established) (This value was introduced in 4.5.)</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.ProxyConnectionTimeoutError</td>
<td>The connection to the proxy server timed out or the proxy server stopped responding in the authentication phase. (This value was introduced in 4.5.)</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.ProxyNotFoundError</td>
<td>The proxy address set with <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setProxy()</span></tt></a> (or the application proxy) was not found. (This value was introduced in 4.5.)</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.ProxyProtocolError</td>
<td>The connection negotiation with the proxy server because the response from the proxy server could not be understood. (This value was introduced in 4.5.)</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.UnknownSocketError</td>
<td>An unidentified error occurred.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractSocket.error()</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.NetworkLayerProtocol">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">NetworkLayerProtocol</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.NetworkLayerProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the network layer protocol values used in Qt.</p>
<table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QAbstractSocket.IPv4Protocol</td>
<td>IPv4</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.IPv6Protocol</td>
<td>IPv6</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.UnknownNetworkLayerProtocol</td>
<td>Other than IPv4 and IPv6</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.PySide.QtNetwork.QHostAddress.protocol" title="PySide.QtNetwork.PySide.QtNetwork.QHostAddress.protocol"><tt class="xref py py-meth docutils literal"><span class="pre">QHostAddress.protocol()</span></tt></a></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketOption">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">SocketOption</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketOption" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum represents the options that can be set on a socket. If desired, they can be set after having received the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connected()</span></tt></a> signal from the socket or after having received a new socket from a <a class="reference internal" href="QTcpServer.html#PySide.QtNetwork.QTcpServer" title="PySide.QtNetwork.QTcpServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpServer</span></tt></a> .</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QAbstractSocket.LowDelayOption</td>
<td>Try to optimize the socket for low latency. For a <a class="reference internal" href="QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> this would set the TCP_NODELAY option and disable Nagle&#8217;s algorithm. Set this to 1 to enable.</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.KeepAliveOption</td>
<td>Set this to 1 to enable the SO_KEEPALIVE socket option</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.MulticastTtlOption</td>
<td>Set this to an integer value to set IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.MulticastLoopbackOption</td>
<td>Set this to 1 to enable the IP_MULTICAST_LOOP (multicast loopback) socket option.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketOption" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketOption"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractSocket.setSocketOption()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketOption" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketOption"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractSocket.socketOption()</span></tt></a></p>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This enum was introduced or modified in Qt 4.6</p>
</div>
<dl class="attribute">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">SocketState</tt><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum describes the different states in which a socket can be.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QAbstractSocket.UnconnectedState</td>
<td>The socket is not connected.</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.HostLookupState</td>
<td>The socket is performing a host name lookup.</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.ConnectingState</td>
<td>The socket has started establishing a connection.</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.ConnectedState</td>
<td>A connection is established.</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.BoundState</td>
<td>The socket is bound to an address and port (for servers).</td>
</tr>
<tr class="row-odd"><td>QAbstractSocket.ClosingState</td>
<td>The socket is about to close (data may still be waiting to be written).</td>
</tr>
<tr class="row-even"><td>QAbstractSocket.ListeningState</td>
<td>For internal use only.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractSocket.state()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.abort">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">abort</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>Aborts the current connection and resets the socket. Unlike <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnectFromHost()</span></tt></a> , this function immediately closes the socket, discarding any pending data in the write buffer.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnectFromHost()</span></tt></a>  <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.close()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">connectToHost</tt><big>(</big><em>hostName</em>, <em>port</em><span class="optional">[</span>, <em>mode=QIODevice.ReadWrite</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hostName</strong> &#8211; unicode</li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
<li><strong>mode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice.OpenMode</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">connectToHost</tt><big>(</big><em>address</em>, <em>port</em><span class="optional">[</span>, <em>mode=QIODevice.ReadWrite</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>address</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
<li><strong>mode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice.OpenMode</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHostImplementation">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">connectToHostImplementation</tt><big>(</big><em>hostName</em>, <em>port</em><span class="optional">[</span>, <em>mode=QIODevice.ReadWrite</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHostImplementation" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>hostName</strong> &#8211; unicode</li>
<li><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></li>
<li><strong>mode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice.OpenMode</span></tt></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">connected</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">disconnectFromHost</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to close the socket. If there is pending data waiting to be written, <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> will enter <tt class="xref py py-attr docutils literal"><span class="pre">ClosingState</span></tt> and wait until all data has been written. Eventually, it will enter <tt class="xref py py-attr docutils literal"><span class="pre">UnconnectedState</span></tt> and emit the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnected()</span></tt></a> signal.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHostImplementation">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">disconnectFromHostImplementation</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHostImplementation" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains the implementation of <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnectFromHost()</span></tt></a> .</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">disconnected</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnected" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">error</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketError</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the type of error that last occurred.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.state()</span></tt></a>  <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.errorString()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">error</tt><big>(</big><em>arg__1</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg__1</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketError</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.flush">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">flush</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.flush" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</p>
<p>Call this function if you need <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.waitForBytesWritten()</span></tt> instead.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt>  <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.waitForBytesWritten()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.hostFound">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">hostFound</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.hostFound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.isValid">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the socket is valid and ready for use; otherwise returns false.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The socket&#8217;s state must be <tt class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></tt> before reading and writing can occur.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.state()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">localAddress</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the host address of the local socket if available; otherwise returns <tt class="xref py py-attr docutils literal"><span class="pre">QHostAddress.Null</span></tt> .</p>
<p>This is normally the main IP address of the host, but can be <tt class="xref py py-attr docutils literal"><span class="pre">QHostAddress.LocalHost</span></tt> (127.0.0.1) for connections to the local host.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setLocalAddress()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">localPort</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the host port number (in native byte order) of the local socket if available; otherwise returns 0.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setLocalPort()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">peerAddress</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the address of the connected peer if the socket is in <tt class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></tt> ; otherwise returns <tt class="xref py py-attr docutils literal"><span class="pre">QHostAddress.Null</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerName()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setPeerAddress()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">peerName</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the name of the peer as specified by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> , or an empty <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QString</span></tt> if <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a> has not been called.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerName" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setPeerName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">peerPort</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the port of the connected peer if the socket is in <tt class="xref py py-attr docutils literal"><span class="pre">ConnectedState</span></tt> ; otherwise returns 0.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setPeerPort()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxy">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">proxy</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QNetworkProxy.html#PySide.QtNetwork.QNetworkProxy" title="PySide.QtNetwork.QNetworkProxy"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkProxy</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the network proxy for this socket. By default <tt class="xref py py-attr docutils literal"><span class="pre">QNetworkProxy.DefaultProxy</span></tt> is used, which means this socket will query the default proxy settings for the application.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setProxy()</span></tt></a>  <a class="reference internal" href="QNetworkProxy.html#PySide.QtNetwork.QNetworkProxy" title="PySide.QtNetwork.QNetworkProxy"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkProxy</span></tt></a>  <a class="reference internal" href="QNetworkProxyFactory.html#PySide.QtNetwork.QNetworkProxyFactory" title="PySide.QtNetwork.QNetworkProxyFactory"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkProxyFactory</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxyAuthenticationRequired">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">proxyAuthenticationRequired</tt><big>(</big><em>proxy</em>, <em>authenticator</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxyAuthenticationRequired" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>proxy</strong> &#8211; <a class="reference internal" href="QNetworkProxy.html#PySide.QtNetwork.QNetworkProxy" title="PySide.QtNetwork.QNetworkProxy"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkProxy</span></tt></a></li>
<li><strong>authenticator</strong> &#8211; <a class="reference internal" href="QAuthenticator.html#PySide.QtNetwork.QAuthenticator" title="PySide.QtNetwork.QAuthenticator"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAuthenticator</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.readBufferSize">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">readBufferSize</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.readBufferSize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt> or <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readAll()</span></tt> .</p>
<p>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setReadBufferSize()</span></tt></a>  <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setLocalAddress</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the address on the local side of a connection to <tt class="docutils literal"><span class="pre">address</span></tt> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> to change the return value of the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localAddress()</span></tt></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local address of the socket prior to a connection (e.g., <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">QUdpSocket.bind()</span></tt></a> ).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setLocalPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setPeerAddress()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setLocalPort</tt><big>(</big><em>port</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></td>
</tr>
</tbody>
</table>
<p>Sets the port on the local side of a connection to <tt class="docutils literal"><span class="pre">port</span></tt> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> to change the return value of the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localPort()</span></tt></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<p>Note that this function does not bind the local port of the socket prior to a connection (e.g., <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind" title="PySide.QtNetwork.PySide.QtNetwork.QUdpSocket.bind"><tt class="xref py py-meth docutils literal"><span class="pre">QUdpSocket.bind()</span></tt></a> ).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.localAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.localAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setLocalAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setPeerPort()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setPeerAddress</tt><big>(</big><em>address</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> &#8211; <a class="reference internal" href="QHostAddress.html#PySide.QtNetwork.QHostAddress" title="PySide.QtNetwork.QHostAddress"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QHostAddress</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the address of the remote side of the connection to <tt class="docutils literal"><span class="pre">address</span></tt> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> to change the return value of the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerAddress()</span></tt></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setPeerPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setLocalAddress()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerName">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setPeerName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; unicode</td>
</tr>
</tbody>
</table>
<p>Sets the host name of the remote peer to <tt class="docutils literal"><span class="pre">name</span></tt> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> to change the return value of the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerName()</span></tt></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setPeerPort</tt><big>(</big><em>port</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerPort" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>port</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.quint16</span></tt></td>
</tr>
</tbody>
</table>
<p>Sets the port of the remote side of the connection to <tt class="docutils literal"><span class="pre">port</span></tt> .</p>
<p>You can call this function in a subclass of <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> to change the return value of the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerPort()</span></tt></a> function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.peerPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.peerPort()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setPeerAddress"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setPeerAddress()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setLocalPort"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setLocalPort()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setProxy</tt><big>(</big><em>networkProxy</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setProxy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>networkProxy</strong> &#8211; <a class="reference internal" href="QNetworkProxy.html#PySide.QtNetwork.QNetworkProxy" title="PySide.QtNetwork.QNetworkProxy"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkProxy</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the explicit network proxy for this socket to <tt class="docutils literal"><span class="pre">networkProxy</span></tt> .</p>
<p>To disable the use of a proxy for this socket, use the <tt class="xref py py-attr docutils literal"><span class="pre">QNetworkProxy.NoProxy</span></tt> proxy type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">socket</span><span class="o">.</span><span class="n">setProxy</span><span class="p">(</span><span class="n">QNetworkProxy</span><span class="o">.</span><span class="n">NoProxy</span><span class="p">)</span>
</pre></div>
</div>
<p>The default value for the proxy is <tt class="xref py py-attr docutils literal"><span class="pre">QNetworkProxy.DefaultProxy</span></tt> , which means the socket will use the application settings: if a proxy is set with QNetworkProxy::setApplicationProxy, it will use that; otherwise, if a factory is set with QNetworkProxyFactory::setApplicationProxyFactory, it will query that factory with type <tt class="xref py py-attr docutils literal"><span class="pre">QNetworkProxyQuery.TcpSocket</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxy" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.proxy"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.proxy()</span></tt></a>  <a class="reference internal" href="QNetworkProxy.html#PySide.QtNetwork.QNetworkProxy" title="PySide.QtNetwork.QNetworkProxy"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkProxy</span></tt></a>  <a class="reference internal" href="QNetworkProxyFactory.html#PySide.QtNetwork.PySide.QtNetwork.QNetworkProxyFactory.queryProxy" title="PySide.QtNetwork.PySide.QtNetwork.QNetworkProxyFactory.queryProxy"><tt class="xref py py-meth docutils literal"><span class="pre">QNetworkProxyFactory.queryProxy()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setReadBufferSize</tt><big>(</big><em>size</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setReadBufferSize" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>Sets the size of <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> &#8216;s internal read buffer to be <tt class="docutils literal"><span class="pre">size</span></tt> bytes.</p>
<p>If the buffer size is limited to a certain size, <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> won&#8217;t buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</p>
<p>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</p>
<p>Only <a class="reference internal" href="QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> uses <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> &#8216;s internal buffer; <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a> has no effect.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.readBufferSize" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.readBufferSize"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.readBufferSize()</span></tt></a>  <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setSocketDescriptor</tt><big>(</big><em>socketDescriptor</em><span class="optional">[</span>, <em>state=ConnectedState</em><span class="optional">[</span>, <em>openMode=QIODevice.ReadWrite</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>socketDescriptor</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></li>
<li><strong>state</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketState</span></tt></a></li>
<li><strong>openMode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice.OpenMode</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketError">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setSocketError</tt><big>(</big><em>socketError</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketError" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>socketError</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketError</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the type of error that last occurred to <tt class="docutils literal"><span class="pre">socketError</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketState" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketState"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setSocketState()</span></tt></a>  <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.setErrorString()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketOption">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setSocketOption</tt><big>(</big><em>option</em>, <em>value</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketOption" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>option</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketOption" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketOption"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketOption</span></tt></a></li>
<li><strong>value</strong> &#8211; object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketState">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">setSocketState</tt><big>(</big><em>state</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketState" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketState</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the state of the socket to <tt class="docutils literal"><span class="pre">state</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.state()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketDescriptor">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">socketDescriptor</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketDescriptor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the native socket descriptor of the <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> object if this is available; otherwise returns -1.</p>
<p>If the socket is using <a class="reference internal" href="QNetworkProxy.html#PySide.QtNetwork.QNetworkProxy" title="PySide.QtNetwork.QNetworkProxy"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkProxy</span></tt></a> , the returned descriptor may not be usable with native socket functions.</p>
<p>The socket descriptor is not available when <a class="reference internal" href="#PySide.QtNetwork.QAbstractSocket" title="PySide.QtNetwork.QAbstractSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket</span></tt></a> is in <tt class="xref py py-attr docutils literal"><span class="pre">UnconnectedState</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.setSocketDescriptor"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.setSocketDescriptor()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketOption">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">socketOption</tt><big>(</big><em>option</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketOption" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>option</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketOption" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketOption"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketOption</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">socketType</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.socketType" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketType" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketType"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketType</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the socket type (TCP, UDP, or other).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a>  <a class="reference internal" href="QUdpSocket.html#PySide.QtNetwork.QUdpSocket" title="PySide.QtNetwork.QUdpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QUdpSocket</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">state</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.state" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketState</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the state of the socket.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.error()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.stateChanged">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">stateChanged</tt><big>(</big><em>arg__1</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.stateChanged" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>arg__1</strong> &#8211; <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketState"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketState</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForConnected">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">waitForConnected</tt><big>(</big><span class="optional">[</span><em>msecs=30000</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForConnected" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msecs</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Waits until the socket is connected, up to <tt class="docutils literal"><span class="pre">msecs</span></tt> milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.error()</span></tt></a> to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be established:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">socket</span><span class="o">.</span><span class="n">connectToHost</span><span class="p">(</span><span class="s">&quot;imap&quot;</span><span class="p">,</span> <span class="mi">143</span><span class="p">)</span>
<span class="k">if</span> <span class="n">socket</span><span class="o">.</span><span class="n">waitForConnected</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot;Connected!&quot;</span>
</pre></div>
</div>
<p>If msecs is -1, this function will not time out.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function may wait slightly longer than <tt class="docutils literal"><span class="pre">msecs</span></tt> , depending on the time it takes to complete the host lookup.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Multiple calls to this functions do not accumulate the time. If the function times out, the connecting process will be aborted.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connectToHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connectToHost()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.connected"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.connected()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForDisconnected">
<tt class="descclassname">PySide.QtNetwork.QAbstractSocket.</tt><tt class="descname">waitForDisconnected</tt><big>(</big><span class="optional">[</span><em>msecs=30000</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.waitForDisconnected" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msecs</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Waits until the socket has disconnected, up to <tt class="docutils literal"><span class="pre">msecs</span></tt> milliseconds. If the connection has been disconnected, this function returns true; otherwise it returns false. In the case where it returns false, you can call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.error"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.error()</span></tt></a> to determine the cause of the error.</p>
<p>The following example waits up to one second for a connection to be closed:</p>
<div class="highlight-python"><pre>socket.disconnectFromHost()
    if socket.state() == QAbstractSocket.UnconnectedState or \
        socket.waitForDisconnected(1000):
        print "Disconnected!"</pre>
</div>
<p>If msecs is -1, this function will not time out.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.disconnectFromHost"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.disconnectFromHost()</span></tt></a>  <tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.close()</span></tt></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>