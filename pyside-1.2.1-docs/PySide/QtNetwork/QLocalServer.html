<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QLocalServer &mdash; PySide 1.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.2.1 documentation" href="../../index.html" />
    <link rel="up" title="PySide.QtNetwork" href="index.html" />
    <link rel="next" title="QSslCertificate" href="QSslCertificate.html" />
    <link rel="prev" title="QTcpServer" href="QTcpServer.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.2.1 documentation</a></li>
                <li> &raquo; <a href="../../modules.html" >PySide modules</a></li>
                <li> &raquo; <a href="index.html" accesskey="U">PySide.QtNetwork</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QLocalServer</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#virtual-functions">Virtual functions</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
<li><a class="reference internal" href="#static-functions">Static functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QTcpServer.html"
                        title="previous chapter">QTcpServer</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QSslCertificate.html"
                        title="next chapter">QSslCertificate</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtNetwork"></span><div class="section" id="qlocalserver">
<span id="id1"></span><h1>QLocalServer<a class="headerlink" href="#qlocalserver" title="Permalink to this headline">¶</a></h1>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close"><tt class="xref py py-meth docutils literal"><span class="pre">close</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString"><tt class="xref py py-meth docutils literal"><span class="pre">errorString</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.fullServerName" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.fullServerName"><tt class="xref py py-meth docutils literal"><span class="pre">fullServerName</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening"><tt class="xref py py-meth docutils literal"><span class="pre">isListening</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">listen</span></tt></a> (name)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.maxPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.maxPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">maxPendingConnections</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError"><tt class="xref py py-meth docutils literal"><span class="pre">serverError</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName"><tt class="xref py py-meth docutils literal"><span class="pre">serverName</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">setMaxPendingConnections</span></tt></a> (numConnections)</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection"><tt class="xref py py-meth docutils literal"><span class="pre">waitForNewConnection</span></tt></a> (msec)</li>
</ul>
</div>
<div class="section" id="virtual-functions">
<h3>Virtual functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">hasPendingConnections</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection"><tt class="xref py py-meth docutils literal"><span class="pre">nextPendingConnection</span></tt></a> ()</li>
</ul>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection"><tt class="xref py py-meth docutils literal"><span class="pre">newConnection</span></tt></a> ()</li>
</ul>
</div>
<div class="section" id="static-functions">
<h3>Static functions<a class="headerlink" href="#static-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.removeServer" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.removeServer"><tt class="xref py py-meth docutils literal"><span class="pre">removeServer</span></tt></a> (name)</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtNetwork.QLocalServer" title="PySide.QtNetwork.QLocalServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer</span></tt></a> class provides a local socket based server.</p>
<p>This class makes it possible to accept incoming local socket connections.</p>
<p>Call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.listen()</span></tt></a> to have the server start listening for incoming connections on a specified key. The <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.newConnection()</span></tt></a> signal is then emitted each time a client connects to the server.</p>
<p>Call <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.nextPendingConnection()</span></tt></a> to accept the pending connection as a connected <a class="reference internal" href="QLocalSocket.html#PySide.QtNetwork.QLocalSocket" title="PySide.QtNetwork.QLocalSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalSocket</span></tt></a> . The function returns a pointer to a <a class="reference internal" href="QLocalSocket.html#PySide.QtNetwork.QLocalSocket" title="PySide.QtNetwork.QLocalSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalSocket</span></tt></a> that can be used for communicating with the client.</p>
<p>If an error occurs, <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.serverError()</span></tt></a> returns the type of error, and <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.errorString()</span></tt></a> can be called to get a human readable description of what happened.</p>
<p>When listening for connections, the name which the server is listening on is available through <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.serverName()</span></tt></a> .</p>
<p>Calling <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.close()</span></tt></a> makes <a class="reference internal" href="#PySide.QtNetwork.QLocalServer" title="PySide.QtNetwork.QLocalServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer</span></tt></a> stop listening for incoming connections.</p>
<p>Although <a class="reference internal" href="#PySide.QtNetwork.QLocalServer" title="PySide.QtNetwork.QLocalServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer</span></tt></a> is designed for use with an event loop, it&#8217;s possible to use it without one. In that case, you must use <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.waitForNewConnection()</span></tt></a> , which blocks until either a connection is available or a timeout expires.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QLocalSocket.html#PySide.QtNetwork.QLocalSocket" title="PySide.QtNetwork.QLocalSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalSocket</span></tt></a>  <a class="reference internal" href="QTcpServer.html#PySide.QtNetwork.QTcpServer" title="PySide.QtNetwork.QTcpServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpServer</span></tt></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide.QtNetwork.QLocalServer">
<em class="property">class </em><tt class="descclassname">PySide.QtNetwork.</tt><tt class="descname">QLocalServer</tt><big>(</big><span class="optional">[</span><em>parent=None</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtNetwork.QLocalServer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parent</strong> &#8211; <a class="reference internal" href="../QtCore/QObject.html#PySide.QtCore.QObject" title="PySide.QtCore.QObject"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QObject</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Create a new local socket server with the given <tt class="docutils literal"><span class="pre">parent</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.listen()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop listening for incoming connections. Existing connections are not effected, but any new connections will be refused.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.isListening()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.listen()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">errorString</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the human-readable message appropriate to the current error reported by <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.serverError()</span></tt></a> . If no suitable string is available, an empty string is returned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.serverError()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.fullServerName">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">fullServerName</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.fullServerName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the full path that the server is listening on.</p>
<p>Note: This is platform specific</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.listen()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.serverName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">hasPendingConnections</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the server has a pending connection; otherwise returns false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.nextPendingConnection()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.setMaxPendingConnections()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">isListening</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the server is listening for incoming connections otherwise false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.listen()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.close()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">listen</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Tells the server to listen for incoming connections on <tt class="docutils literal"><span class="pre">name</span></tt> . If the server is currently listening then it will return false. Return true on success otherwise false.</p>
<p><tt class="docutils literal"><span class="pre">name</span></tt> can be a single name and <a class="reference internal" href="#PySide.QtNetwork.QLocalServer" title="PySide.QtNetwork.QLocalServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer</span></tt></a> will determine the correct platform specific path. <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.serverName()</span></tt></a> will return the name that is passed into listen.</p>
<p>Usually you would just pass in a name like &#8220;foo&#8221;, but on Unix this could also be a path such as &#8220;/tmp/foo&#8221; and on Windows this could be a pipe path such as &#8220;\.pipefoo&#8221;</p>
<p>Note: On Unix if the server crashes without closing listen will fail with AddressInUseError. To create a new server the file should be removed. On Windows two local servers can listen to the same pipe at the same time, but any connections will go to one of the server.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.serverName()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.isListening"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.isListening()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.close"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.close()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.maxPendingConnections">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">maxPendingConnections</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.maxPendingConnections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the maximum number of pending accepted connections. The default is 30.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.setMaxPendingConnections()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.hasPendingConnections()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">newConnection</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">nextPendingConnection</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QLocalSocket.html#PySide.QtNetwork.QLocalSocket" title="PySide.QtNetwork.QLocalSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalSocket</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the next pending connection as a connected <a class="reference internal" href="QLocalSocket.html#PySide.QtNetwork.QLocalSocket" title="PySide.QtNetwork.QLocalSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalSocket</span></tt></a> object.</p>
<p>The socket is created as a child of the server, which means that it is automatically deleted when the <a class="reference internal" href="#PySide.QtNetwork.QLocalServer" title="PySide.QtNetwork.QLocalServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer</span></tt></a> object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</p>
<p>0 is returned if this function is called when there are no pending connections.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.hasPendingConnections()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.newConnection()</span></tt></a>  <tt class="xref py py-meth docutils literal"><span class="pre">incomingConnection()</span></tt></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.removeServer">
<em class="property">static </em><tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">removeServer</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.removeServer" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Removes any server instance that might cause a call to <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.listen()</span></tt></a> to fail and returns true if successful; otherwise returns false. This function is meant to recover from a crash, when the previous server instance has not been cleaned up.</p>
<p>On Windows, this function does nothing; on Unix, it removes the socket file given by <tt class="docutils literal"><span class="pre">name</span></tt> .</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be careful to avoid removing sockets of running instances.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">serverError</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverError" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QAbstractSocket.html#PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError" title="PySide.QtNetwork.PySide.QtNetwork.QAbstractSocket.SocketError"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtNetwork.QAbstractSocket.SocketError</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the type of error that occurred last or NoError.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.errorString"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.errorString()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">serverName</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.serverName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns the server name if the server is listening for connections; otherwise returns <tt class="xref py py-meth docutils literal"><span class="pre">QString()</span></tt></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.listen"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.listen()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.fullServerName" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.fullServerName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.fullServerName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">setMaxPendingConnections</tt><big>(</big><em>numConnections</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.setMaxPendingConnections" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>numConnections</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
</tbody>
</table>
<p>Sets the maximum number of pending accepted connections to <tt class="docutils literal"><span class="pre">numConnections</span></tt> . <a class="reference internal" href="#PySide.QtNetwork.QLocalServer" title="PySide.QtNetwork.QLocalServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer</span></tt></a> will accept no more than <tt class="docutils literal"><span class="pre">numConnections</span></tt> incoming connections before <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.nextPendingConnection()</span></tt></a> is called.</p>
<p>Note: Even though <a class="reference internal" href="#PySide.QtNetwork.QLocalServer" title="PySide.QtNetwork.QLocalServer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer</span></tt></a> will stop accepting new connections after it has reached its maximum number of pending connections, the operating system may still keep them in queue which will result in clients signaling that it is connected.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.maxPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.maxPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.maxPendingConnections()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.hasPendingConnections()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection">
<tt class="descclassname">PySide.QtNetwork.QLocalServer.</tt><tt class="descname">waitForNewConnection</tt><big>(</big><em>msec</em><big>)</big><a class="headerlink" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msec</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(retval, timeOut)</td>
</tr>
</tbody>
</table>
<p>Waits for at most <tt class="docutils literal"><span class="pre">msec</span></tt> milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and <tt class="docutils literal"><span class="pre">timedOut</span></tt> is not 0, *timedOut will be set to true.</p>
<p>This is a blocking function call. Its use is ill-advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.waitForNewConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.waitForNewConnection()</span></tt></a> is mostly useful when there is no event loop available.</p>
<p>The non-blocking alternative is to connect to the <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.newConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.newConnection()</span></tt></a> signal.</p>
<p>If msec is -1, this function will not time out.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.hasPendingConnections"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.hasPendingConnections()</span></tt></a>  <a class="reference internal" href="#PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection" title="PySide.QtNetwork.PySide.QtNetwork.QLocalServer.nextPendingConnection"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtNetwork.QLocalServer.nextPendingConnection()</span></tt></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>