<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QXmlQuery &mdash; PySide 1.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.2.1 documentation" href="../../index.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.2.1 documentation</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QXmlQuery</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a><ul>
<li><a class="reference internal" href="#running-xqueries">Running XQueries</a></li>
<li><a class="reference internal" href="#running-xpath-expressions">Running XPath Expressions</a></li>
<li><a class="reference internal" href="#running-xslt-stylesheets">Running XSLT stylesheets</a></li>
<li><a class="reference internal" href="#binding-a-query-to-a-starting-node">Binding A Query To A Starting Node</a></li>
<li><a class="reference internal" href="#reentrancy-and-thread-safety">Reentrancy and Thread-Safety</a></li>
<li><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li><a class="reference internal" href="#resource-management">Resource Management</a></li>
<li><a class="reference internal" href="#event-handling">Event Handling</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtXmlPatterns"></span><div class="section" id="qxmlquery">
<span id="id1"></span><h1>QXmlQuery<a class="headerlink" href="#qxmlquery" title="Permalink to this headline">¶</a></h1>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">bindVariable</span></tt></a> (localName, arg__2)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">bindVariable</span></tt></a> (localName, query)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">bindVariable</span></tt></a> (localName, value)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">bindVariable</span></tt></a> (name, arg__2)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">bindVariable</span></tt></a> (name, query)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">bindVariable</span></tt></a> (name, value)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo"><tt class="xref py py-meth docutils literal"><span class="pre">evaluateTo</span></tt></a> (callback)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo"><tt class="xref py py-meth docutils literal"><span class="pre">evaluateTo</span></tt></a> (result)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo"><tt class="xref py py-meth docutils literal"><span class="pre">evaluateTo</span></tt></a> (target)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName"><tt class="xref py py-meth docutils literal"><span class="pre">initialTemplateName</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">isValid</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">messageHandler</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.namePool" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.namePool"><tt class="xref py py-meth docutils literal"><span class="pre">namePool</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.networkAccessManager" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.networkAccessManager"><tt class="xref py py-meth docutils literal"><span class="pre">networkAccessManager</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.queryLanguage" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.queryLanguage"><tt class="xref py py-meth docutils literal"><span class="pre">queryLanguage</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus"><tt class="xref py py-meth docutils literal"><span class="pre">setFocus</span></tt></a> (document)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus"><tt class="xref py py-meth docutils literal"><span class="pre">setFocus</span></tt></a> (documentURI)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus"><tt class="xref py py-meth docutils literal"><span class="pre">setFocus</span></tt></a> (focus)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus"><tt class="xref py py-meth docutils literal"><span class="pre">setFocus</span></tt></a> (item)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName"><tt class="xref py py-meth docutils literal"><span class="pre">setInitialTemplateName</span></tt></a> (name)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName"><tt class="xref py py-meth docutils literal"><span class="pre">setInitialTemplateName</span></tt></a> (name)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setMessageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setMessageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">setMessageHandler</span></tt></a> (messageHandler)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setNetworkAccessManager" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setNetworkAccessManager"><tt class="xref py py-meth docutils literal"><span class="pre">setNetworkAccessManager</span></tt></a> (newManager)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">setQuery</span></tt></a> (queryURI[, baseURI=QUrl()])</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">setQuery</span></tt></a> (sourceCode[, documentURI=QUrl()])</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">setQuery</span></tt></a> (sourceCode[, documentURI=QUrl()])</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setUriResolver" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setUriResolver"><tt class="xref py py-meth docutils literal"><span class="pre">setUriResolver</span></tt></a> (resolver)</li>
<li>def <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.uriResolver" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.uriResolver"><tt class="xref py py-meth docutils literal"><span class="pre">uriResolver</span></tt></a> ()</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> class performs XQueries on XML data, or on non-XML data modeled to look like XML.</p>
<p>The <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> class compiles and executes queries written in the <em class="xref std std-ref">XQuery</em> language. <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> is typically used to query XML data, but it can also query non-XML data that has been modeled to look like XML.</p>
<p>Using <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to query XML data, as in the snippet below, is simple because it can use the built-in <a class="reference internal" href="QAbstractXmlNodeModel.html#PySide.QtXmlPatterns.QAbstractXmlNodeModel" title="PySide.QtXmlPatterns.QAbstractXmlNodeModel"><tt class="xref py py-class docutils literal"><span class="pre">XML</span> <span class="pre">data</span> <span class="pre">model</span></tt></a> as its delegate to the underlying query engine for traversing the data. The built-in data model is specified in <em class="xref std std-ref">XQuery</em> 1.0 and XPath 2.0 Data Model.</p>
<div class="highlight-python"><pre>QXmlQuery query;
query.setQuery("doc('index.html')/html/body/p[1]");

QXmlSerializer serializer(query, myOutputDevice);
query.evaluateTo(&amp;serializer);</pre>
</div>
<p>The example uses <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to match the first paragraph of an XML document and then <a class="reference internal" href="QXmlSerializer.html#PySide.QtXmlPatterns.QXmlSerializer" title="PySide.QtXmlPatterns.QXmlSerializer"><tt class="xref py py-class docutils literal"><span class="pre">output</span> <span class="pre">the</span> <span class="pre">result</span></tt></a> to a device as XML.</p>
<p>Using <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to query <em>non-XML</em> data requires writing a subclass of <a class="reference internal" href="QAbstractXmlNodeModel.html#PySide.QtXmlPatterns.QAbstractXmlNodeModel" title="PySide.QtXmlPatterns.QAbstractXmlNodeModel"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractXmlNodeModel</span></tt></a> to use as a replacement for the built-in XML data model. The custom data model will be able to traverse the non-XML data as required by the <a class="reference internal" href="QAbstractXmlNodeModel.html#PySide.QtXmlPatterns.QAbstractXmlNodeModel" title="PySide.QtXmlPatterns.QAbstractXmlNodeModel"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractXmlNodeModel</span></tt></a> interface. An instance of this custom data model then becomes the delegate used by the query engine to traverse the non-XML data. For an example of how to use <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to query non-XML data, see the documentation for <a class="reference internal" href="QAbstractXmlNodeModel.html#PySide.QtXmlPatterns.QAbstractXmlNodeModel" title="PySide.QtXmlPatterns.QAbstractXmlNodeModel"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractXmlNodeModel</span></tt></a> .</p>
</div></blockquote>
<div class="section" id="running-xqueries">
<span id="pyside-qtxmlpatterns-qxmlquery-running-xqueries"></span><h3>Running XQueries<a class="headerlink" href="#running-xqueries" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>To run a query set up with <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> , call one of the evaluation functions.</p>
<ul class="simple">
<li>evaluateTo( <a class="reference internal" href="QAbstractXmlReceiver.html#PySide.QtXmlPatterns.QAbstractXmlReceiver" title="PySide.QtXmlPatterns.QAbstractXmlReceiver"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractXmlReceiver</span></tt></a> *) is called with a pointer to an XML <a class="reference internal" href="QAbstractXmlReceiver.html#PySide.QtXmlPatterns.QAbstractXmlReceiver" title="PySide.QtXmlPatterns.QAbstractXmlReceiver"><tt class="xref py py-class docutils literal"><span class="pre">receiver</span></tt></a> , which receives the query results as a sequence of callbacks. The receiver callback class is like the callback class used for translating the output of a SAX parser. <a class="reference internal" href="QXmlSerializer.html#PySide.QtXmlPatterns.QXmlSerializer" title="PySide.QtXmlPatterns.QXmlSerializer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlSerializer</span></tt></a> , for example, is a receiver callback class for translating the sequence of callbacks for output as unformatted XML text.</li>
<li>evaluateTo( <a class="reference internal" href="QXmlResultItems.html#PySide.QtXmlPatterns.QXmlResultItems" title="PySide.QtXmlPatterns.QXmlResultItems"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlResultItems</span></tt></a> *) is called with a pointer to an iterator for an empty sequence of query <a class="reference internal" href="QXmlResultItems.html#PySide.QtXmlPatterns.QXmlResultItems" title="PySide.QtXmlPatterns.QXmlResultItems"><tt class="xref py py-class docutils literal"><span class="pre">result</span> <span class="pre">items</span></tt></a> . The Java-like iterator allows the query results to be accessed sequentially.</li>
<li>evaluateTo( <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QStringList</span></tt> *) is like evaluateTo( <a class="reference internal" href="QXmlResultItems.html#PySide.QtXmlPatterns.QXmlResultItems" title="PySide.QtXmlPatterns.QXmlResultItems"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlResultItems</span></tt></a> *), but the query must evaluate to a sequence of strings.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="running-xpath-expressions">
<span id="pyside-qtxmlpatterns-qxmlquery-running-xpath-expressions"></span><h3>Running XPath Expressions<a class="headerlink" href="#running-xpath-expressions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>The XPath language is a subset of the <em class="xref std std-ref">XQuery</em> language, so running an XPath expression is the same as running an <em class="xref std std-ref">XQuery</em> query. Pass the XPath expression to <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> using <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> .</div></blockquote>
</div>
<div class="section" id="running-xslt-stylesheets">
<span id="pyside-qtxmlpatterns-qxmlquery-running-xslt-stylesheets"></span><h3>Running XSLT stylesheets<a class="headerlink" href="#running-xslt-stylesheets" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Running an XSLT stylesheet is like running an <em class="xref std std-ref">XQuery</em> , except that when you construct your <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> , you must pass <tt class="xref py py-attr docutils literal"><span class="pre">QXmlQuery.XSLT20</span></tt> to tell <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to interpret whatever it gets from <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> as an XSLT stylesheet instead of as an <em class="xref std std-ref">XQuery</em> . You must also set the input document by calling <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setFocus()</span></tt></a> .</p>
<div class="highlight-python"><pre>QXmlQuery query(QXmlQuery::XSLT20);
query.setFocus(QUrl("myInput.xml"));
query.setQuery(QUrl("myStylesheet.xsl"));
query.evaluateTo(out);</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setFocus()</span></tt></a> must be called <em>before</em><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> when using XSLT.</p>
</div>
<p>Another way to run an XSLT stylesheet is to use the <tt class="docutils literal"><span class="pre">xmlpatterns</span></tt> command line utility.</p>
<div class="highlight-python"><pre>xmlpatterns myStylesheet.xsl myInput.xml</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the current release, XSLT support should be considered experimental. See section <em class="xref std std-ref">XSLT conformance</em> for details.</p>
</div>
<p>Stylesheet parameters are bound using <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.bindVariable()</span></tt></a> .</p>
</div></blockquote>
</div>
<div class="section" id="binding-a-query-to-a-starting-node">
<span id="pyside-qtxmlpatterns-qxmlquery-binding-a-query-to-a-starting-node"></span><h3>Binding A Query To A Starting Node<a class="headerlink" href="#binding-a-query-to-a-starting-node" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>When a query is run on XML data, as in the snippet above, the <tt class="docutils literal"><span class="pre">doc()</span></tt> function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.bindVariable()</span></tt></a> functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the <em class="xref std std-ref">XQuery</em> text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for <a class="reference internal" href="QAbstractXmlNodeModel.html#PySide.QtXmlPatterns.QAbstractXmlNodeModel" title="PySide.QtXmlPatterns.QAbstractXmlNodeModel"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractXmlNodeModel</span></tt></a> .</div></blockquote>
</div>
<div class="section" id="reentrancy-and-thread-safety">
<span id="pyside-qtxmlpatterns-qxmlquery-reentrancy-and-thread-safety"></span><h3>Reentrancy and Thread-Safety<a class="headerlink" href="#reentrancy-and-thread-safety" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> is reentrant but not thread-safe. It is safe to use the QxmlQuery copy constructor to create a copy of a query and run the same query multiple times. Behind the scenes, <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> will reuse resources such as opened files and compiled queries to the extent possible. But it is not safe to use the same instance of <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> in multiple threads.</div></blockquote>
</div>
<div class="section" id="error-handling">
<span id="pyside-qtxmlpatterns-qxmlquery-error-handling"></span><h3>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Errors can occur during query evaluation. Examples include type errors and file loading errors. When an error occurs:</p>
<ul class="simple">
<li>The error message is sent to the <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.messageHandler()</span></tt></a> .</li>
<li><a class="reference internal" href="QXmlResultItems.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlResultItems.hasError" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlResultItems.hasError"><tt class="xref py py-meth docutils literal"><span class="pre">QXmlResultItems.hasError()</span></tt></a> will return <tt class="docutils literal"><span class="pre">true</span></tt>, or <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.evaluateTo()</span></tt></a> will return <tt class="docutils literal"><span class="pre">false</span></tt>;</li>
<li>The results of the evaluation are undefined.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="resource-management">
<span id="pyside-qtxmlpatterns-qxmlquery-resource-management"></span><h3>Resource Management<a class="headerlink" href="#resource-management" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</p>
<p>When <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> for each query text.</p>
<p>Once a document has been parsed, its internal representation is maintained in the <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> instance and shared among multiple <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> instances.</p>
<p>An instance of <a class="reference internal" href="../QtCore/QCoreApplication.html#PySide.QtCore.QCoreApplication" title="PySide.QtCore.QCoreApplication"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QCoreApplication</span></tt></a> must exist before <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> can be used.</p>
</div></blockquote>
</div>
<div class="section" id="event-handling">
<span id="pyside-qtxmlpatterns-qxmlquery-event-handling"></span><h3>Event Handling<a class="headerlink" href="#event-handling" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div>When <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> accesses resources (e.g., calling <tt class="docutils literal"><span class="pre">fn:doc()</span></tt> to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> accesses resources, create your <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> instance in a separate thread.</div></blockquote>
<dl class="class">
<dt id="PySide.QtXmlPatterns.QXmlQuery">
<em class="property">class </em><tt class="descclassname">PySide.QtXmlPatterns.</tt><tt class="descname">QXmlQuery</tt><a class="headerlink" href="#PySide.QtXmlPatterns.QXmlQuery" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property">class </em><tt class="descclassname">PySide.QtXmlPatterns.</tt><tt class="descname">QXmlQuery</tt><big>(</big><em>queryLanguage</em><span class="optional">[</span>, <em>np=QXmlNamePool()</em><span class="optional">]</span><big>)</big></dt>
<dt>
<em class="property">class </em><tt class="descclassname">PySide.QtXmlPatterns.</tt><tt class="descname">QXmlQuery</tt><big>(</big><em>np</em><big>)</big></dt>
<dt>
<em class="property">class </em><tt class="descclassname">PySide.QtXmlPatterns.</tt><tt class="descname">QXmlQuery</tt><big>(</big><em>other</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>np</strong> &#8211; <a class="reference internal" href="QXmlNamePool.html#PySide.QtXmlPatterns.QXmlNamePool" title="PySide.QtXmlPatterns.QXmlNamePool"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlNamePool</span></tt></a></li>
<li><strong>other</strong> &#8211; <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a></li>
<li><strong>queryLanguage</strong> &#8211; <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.QueryLanguage" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.QueryLanguage"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.QueryLanguage</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Constructs an invalid, empty query that cannot be used until <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> is called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This constructor must not be used if you intend to use this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to process XSL-T stylesheets. The other constructor must be used in that case.</p>
</div>
<p>Constructs a query that will be used to run Xqueries or XSL-T stylesheets, depending on the value of <tt class="docutils literal"><span class="pre">queryLanguage</span></tt> . It will use <tt class="docutils literal"><span class="pre">np</span></tt> as its name pool.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If your <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> will process XSL-T stylesheets, this constructor must be used. The default constructor can only create instances of <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> for running XQueries.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The XSL-T support in this release is considered experimental. See the <em class="xref std std-ref">XSLT conformance</em> for details.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.queryLanguage" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.queryLanguage"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.queryLanguage()</span></tt></a></p>
</div>
<p>Constructs a query that will use <tt class="docutils literal"><span class="pre">np</span></tt> as its name pool. The query cannot be evaluated until <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> has been called.</p>
<p>Constructs a <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> that is a copy of <tt class="docutils literal"><span class="pre">other</span></tt> . The new instance will share resources with the existing query to the extent possible.</p>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.QueryLanguage">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">QueryLanguage</tt><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.QueryLanguage" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies whether you want <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to interpret the input to <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> as an <em class="xref std std-ref">XQuery</em> or as an XSLT stylesheet.</p>
<table border="1" class="docutils">
<colgroup>
<col width="2%" />
<col width="98%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QXmlQuery.XQuery10</td>
<td><em class="xref std std-ref">XQuery</em> 1.0.</td>
</tr>
<tr class="row-odd"><td>QXmlQuery.XSLT20</td>
<td>XSLT 2.0 The selector, the restricted XPath pattern found in W3C XML Schema 1.1 for uniqueness contraints. Apart from restricting the syntax, the type check stage for the expression assumes a sequence of nodes to be the focus. The field, the restricted XPath pattern found in W3C XML Schema 1.1 for uniqueness contraints. Apart from restricting the syntax, the type check stage for the expression assumes a sequence of nodes to be the focus. Signifies XPath 2.0. Has no effect in the public API, it&#8217;s used internally. As With <tt class="xref py py-attr docutils literal"><span class="pre">XmlSchema11IdentityConstraintSelector</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">XmlSchema11IdentityConstraintField</span></tt> , the type check stage for the expression assumes a sequence of nodes to be the focus.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">bindVariable</tt><big>(</big><em>name</em>, <em>query</em><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a></li>
<li><strong>query</strong> &#8211; <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Binds the result of the query <tt class="docutils literal"><span class="pre">query</span></tt> , to a variable by name <tt class="docutils literal"><span class="pre">name</span></tt> .</p>
<p>Evaluation of <tt class="docutils literal"><span class="pre">query</span></tt> will be commenced when this function is called.</p>
<p>If <tt class="docutils literal"><span class="pre">query</span></tt> is invalid, behavior is undefined. <tt class="docutils literal"><span class="pre">query</span></tt> will be copied.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.isValid()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">bindVariable</tt><big>(</big><em>name</em>, <em>arg__2</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a></li>
<li><strong>arg__2</strong> &#8211; <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Binds the variable <tt class="docutils literal"><span class="pre">name</span></tt> to the <tt class="docutils literal"><span class="pre">device</span></tt> so that $``name`` can be used from within the query to refer to the <tt class="docutils literal"><span class="pre">device</span></tt> . The <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> <tt class="docutils literal"><span class="pre">device</span></tt> is exposed to the query as a URI of type <tt class="docutils literal"><span class="pre">xs:anyURI</span></tt> , which can be passed to the <tt class="docutils literal"><span class="pre">fn:doc()</span></tt> function to be read. E.g., this function can be used to pass an XML document in memory to <tt class="docutils literal"><span class="pre">fn:doc</span></tt> .</p>
<div class="highlight-python"><pre>QByteArray myDocument;
QBuffer buffer(&amp;myDocument); // This is a QIODevice.
buffer.open(QIODevice::ReadOnly);
QXmlQuery query;
query.bindVariable("myDocument", &amp;buffer);
query.setQuery("doc($myDocument)");</pre>
</div>
<p>The caller must ensure that <tt class="docutils literal"><span class="pre">device</span></tt> has been opened with at least <tt class="xref py py-attr docutils literal"><span class="pre">QIODevice.ReadOnly</span></tt> prior to this binding. Otherwise, behavior is undefined.</p>
<p>If the query will access an XML document contained in a <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QString</span></tt> , use a <a class="reference internal" href="../QtCore/QBuffer.html#PySide.QtCore.QBuffer" title="PySide.QtCore.QBuffer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QBuffer</span></tt></a> as shown in the following snippet. Suppose <em>myQString</em> contains <tt class="docutils literal"><span class="pre">&lt;document&gt;content&lt;/document&gt;</span></tt></p>
<div class="highlight-python"><pre>QBuffer device;
device.setData(myQString.toUtf8());
device.open(QIODevice::ReadOnly);

QXmlQuery query;
query.setQuery("doc($inputDocument)/query[theDocument]");
query.bindVariable("inputDocument", &amp;device);</pre>
</div>
<p><tt class="docutils literal"><span class="pre">name</span></tt> must not be <em>null</em> . <tt class="docutils literal"><span class="pre">name</span></tt> . <tt class="xref py py-meth docutils literal"><span class="pre">isNull()</span></tt> must return false. If <tt class="docutils literal"><span class="pre">name</span></tt> has already been bound, its previous binding will be overridden. The URI that <tt class="docutils literal"><span class="pre">name</span></tt> evaluates to is arbitrary and may change.</p>
<p>If the type of the variable binding changes (e.g., if a previous binding by the same name was a <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QVariant</span></tt> , or if there was no previous binding), <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.isValid()</span></tt></a> will return <tt class="docutils literal"><span class="pre">false</span></tt> , and recompilation of the query text is required. To recompile the query, call <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> . For this reason, <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.bindVariable()</span></tt></a> should be called before <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> , if possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">device</span></tt> must not be deleted while this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> exists.</p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">bindVariable</tt><big>(</big><em>name</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> &#8211; <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a></li>
<li><strong>value</strong> &#8211; <a class="reference internal" href="QXmlItem.html#PySide.QtXmlPatterns.QXmlItem" title="PySide.QtXmlPatterns.QXmlItem"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlItem</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Binds the variable <tt class="docutils literal"><span class="pre">name</span></tt> to the <tt class="docutils literal"><span class="pre">value</span></tt> so that $``name`` can be used from within the query to refer to the <tt class="docutils literal"><span class="pre">value</span></tt> .</p>
<p><tt class="docutils literal"><span class="pre">name</span></tt> must not be <em>null</em> . <tt class="docutils literal"><span class="pre">name</span></tt> . <tt class="xref py py-meth docutils literal"><span class="pre">isNull()</span></tt> must return false. If <tt class="docutils literal"><span class="pre">name</span></tt> has already been bound by a previous <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.bindVariable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.bindVariable()</span></tt></a> call, its previous binding will be overridden.</p>
<p>If <tt class="docutils literal"><span class="pre">value</span></tt> is null so that <tt class="docutils literal"><span class="pre">value</span></tt> . <tt class="xref py py-meth docutils literal"><span class="pre">isNull()</span></tt> returns true, and <tt class="docutils literal"><span class="pre">name</span></tt> already has a binding, the effect is to remove the existing binding for <tt class="docutils literal"><span class="pre">name</span></tt> .</p>
<p>To bind a value of type <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QString</span></tt> or <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a> , wrap the value in a <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QVariant</span></tt> such that <a class="reference internal" href="QXmlItem.html#PySide.QtXmlPatterns.QXmlItem" title="PySide.QtXmlPatterns.QXmlItem"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlItem</span></tt></a> &#8216;s <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QVariant</span></tt> constructor is called.</p>
<p>All strings processed by the query must be valid <em class="xref std std-ref">XQuery</em> strings, which means they must contain only XML 1.0 characters. However, this requirement is not checked. If the query processes an invalid string, the behavior is undefined.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">QVariant.isValid()</span></tt>  <em class="xref std std-ref">How QVariant maps to XQuery&#8217;s Data Model</em>  <a class="reference internal" href="QXmlItem.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlItem.isNull" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlItem.isNull"><tt class="xref py py-meth docutils literal"><span class="pre">QXmlItem.isNull()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">bindVariable</tt><big>(</big><em>localName</em>, <em>arg__2</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localName</strong> &#8211; unicode</li>
<li><strong>arg__2</strong> &#8211; <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>If <tt class="docutils literal"><span class="pre">localName</span></tt> is a valid <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.isNCName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.isNCName"><tt class="xref py py-meth docutils literal"><span class="pre">NCName</span></tt></a> , this function is equivalent to the following snippet.</p>
<div class="highlight-python"><pre>QXmlNamePool namePool(query.namePool());
query.bindVariable(QXmlName(namePool, localName), device);</pre>
</div>
<p>A <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a> is constructed from <tt class="docutils literal"><span class="pre">localName</span></tt> , and is passed to the appropriate overload along with <tt class="docutils literal"><span class="pre">device</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.isNCName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.isNCName"><tt class="xref py py-meth docutils literal"><span class="pre">QXmlName.isNCName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">bindVariable</tt><big>(</big><em>localName</em>, <em>query</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localName</strong> &#8211; unicode</li>
<li><strong>query</strong> &#8211; <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Has the same behavior and effects as the function being overloaded, but takes the variable name <tt class="docutils literal"><span class="pre">localName</span></tt> as a <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QString</span></tt> . <tt class="docutils literal"><span class="pre">query</span></tt> is used as in the overloaded function.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">bindVariable</tt><big>(</big><em>localName</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>localName</strong> &#8211; unicode</li>
<li><strong>value</strong> &#8211; <a class="reference internal" href="QXmlItem.html#PySide.QtXmlPatterns.QXmlItem" title="PySide.QtXmlPatterns.QXmlItem"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlItem</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>This function constructs a <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a> from <tt class="docutils literal"><span class="pre">localName</span></tt> using the query&#8217;s <a class="reference internal" href="QXmlNamePool.html#PySide.QtXmlPatterns.QXmlNamePool" title="PySide.QtXmlPatterns.QXmlNamePool"><tt class="xref py py-class docutils literal"><span class="pre">namespace</span></tt></a> . The function then behaves as the overloaded function. It is equivalent to the following snippet.</p>
<div class="highlight-python"><pre>QXmlNamePool namePool(query.namePool());
query.bindVariable(QXmlName(namePool, localName), value);</pre>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">evaluateTo</tt><big>(</big><em>result</em><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.evaluateTo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>result</strong> &#8211; <a class="reference internal" href="QXmlResultItems.html#PySide.QtXmlPatterns.QXmlResultItems" title="PySide.QtXmlPatterns.QXmlResultItems"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlResultItems</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Starts the evaluation and makes it available in <tt class="docutils literal"><span class="pre">result</span></tt> . If <tt class="docutils literal"><span class="pre">result</span></tt> is null, the behavior is undefined. The evaluation takes place incrementally (lazy evaluation), as the caller uses <a class="reference internal" href="QXmlResultItems.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlResultItems.next" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlResultItems.next"><tt class="xref py py-meth docutils literal"><span class="pre">QXmlResultItems.next()</span></tt></a> to get the next result.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QXmlResultItems.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlResultItems.next" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlResultItems.next"><tt class="xref py py-meth docutils literal"><span class="pre">QXmlResultItems.next()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">evaluateTo</tt><big>(</big><em>target</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>target</strong> &#8211; <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Evaluates the query or stylesheet, and writes the output to <tt class="docutils literal"><span class="pre">target</span></tt> .</p>
<p><a class="reference internal" href="QXmlSerializer.html#PySide.QtXmlPatterns.QXmlSerializer" title="PySide.QtXmlPatterns.QXmlSerializer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlSerializer</span></tt></a> is used to write the output to <tt class="docutils literal"><span class="pre">target</span></tt> . In a future release, it is expected that this function will be changed to respect serialization options set in the stylesheet.</p>
<p>If an error occurs during the evaluation, error messages are sent to <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.messageHandler()</span></tt></a> and <tt class="docutils literal"><span class="pre">false</span></tt> is returned.</p>
<p>If <tt class="docutils literal"><span class="pre">target</span></tt> is <tt class="docutils literal"><span class="pre">null</span></tt> , or is not opened in at least <tt class="xref py py-attr docutils literal"><span class="pre">QIODevice.WriteOnly</span></tt> mode, the behavior is undefined. <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> does not take ownership of <tt class="docutils literal"><span class="pre">target</span></tt> .</p>
<p>This is an overloaded function.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">evaluateTo</tt><big>(</big><em>callback</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callback</strong> &#8211; <a class="reference internal" href="QAbstractXmlReceiver.html#PySide.QtXmlPatterns.QAbstractXmlReceiver" title="PySide.QtXmlPatterns.QAbstractXmlReceiver"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractXmlReceiver</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Evaluates this query and sends the result as a sequence of callbacks to the <a class="reference internal" href="QAbstractXmlReceiver.html#PySide.QtXmlPatterns.QAbstractXmlReceiver" title="PySide.QtXmlPatterns.QAbstractXmlReceiver"><tt class="xref py py-class docutils literal"><span class="pre">receiver</span></tt></a> <tt class="docutils literal"><span class="pre">callback</span></tt> . <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> does not take ownership of <tt class="docutils literal"><span class="pre">callback</span></tt> .</p>
<p>If an error occurs during the evaluation, error messages are sent to <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.messageHandler()</span></tt></a> and <tt class="docutils literal"><span class="pre">false</span></tt> is returned.</p>
<p>If this query <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">is</span> <span class="pre">invalid</span></tt></a> , <tt class="docutils literal"><span class="pre">false</span></tt> is returned and the behavior is undefined. If <tt class="docutils literal"><span class="pre">callback</span></tt> is null, behavior is undefined.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QAbstractXmlReceiver.html#PySide.QtXmlPatterns.QAbstractXmlReceiver" title="PySide.QtXmlPatterns.QAbstractXmlReceiver"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractXmlReceiver</span></tt></a>  <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.isValid()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">initialTemplateName</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the name of the XSL-T stylesheet template that the processor will call first when running an XSL-T stylesheet. This function only applies when using <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to process XSL-T stylesheets. By default, no initial template is set. In that case, a default constructed <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a> is returned.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">isValid</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if this query is valid. Examples of invalid queries are ones that contain syntax errors or that have not had <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> called for them yet.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">messageHandler</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QAbstractMessageHandler.html#PySide.QtXmlPatterns.QAbstractMessageHandler" title="PySide.QtXmlPatterns.QAbstractMessageHandler"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractMessageHandler</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the message handler that handles compile and runtime messages for this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setMessageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setMessageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setMessageHandler()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.namePool">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">namePool</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.namePool" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QXmlNamePool.html#PySide.QtXmlPatterns.QXmlNamePool" title="PySide.QtXmlPatterns.QXmlNamePool"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlNamePool</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the name pool used by this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> for constructing <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">names</span></tt></a> . There is no setter for the name pool, because mixing name pools causes errors due to name confusion.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.networkAccessManager">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">networkAccessManager</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.networkAccessManager" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="../QtNetwork/QNetworkAccessManager.html#PySide.QtNetwork.QNetworkAccessManager" title="PySide.QtNetwork.QNetworkAccessManager"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkAccessManager</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the network manager, or 0 if it has not been set.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setNetworkAccessManager" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setNetworkAccessManager"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setNetworkAccessManager()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.queryLanguage">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">queryLanguage</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.queryLanguage" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.QueryLanguage" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.QueryLanguage"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.QueryLanguage</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns a value indicating what this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> is being used for. The default is <tt class="xref py py-attr docutils literal"><span class="pre">QXmlQuery.XQuery10</span></tt> , which means the <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> is being used for running <em class="xref std std-ref">XQuery</em> and XPath queries. <tt class="xref py py-attr docutils literal"><span class="pre">QXmlQuery.XSLT20</span></tt> can also be returned, which indicates the <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> is for running XSL-T spreadsheets.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setFocus</tt><big>(</big><em>item</em><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>item</strong> &#8211; <a class="reference internal" href="QXmlItem.html#PySide.QtXmlPatterns.QXmlItem" title="PySide.QtXmlPatterns.QXmlItem"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlItem</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the focus to <tt class="docutils literal"><span class="pre">item</span></tt> . The focus is the set of items that the context item expression and path expressions navigate from. For example, in the expression <em>p/span</em> , the element that <em>p</em> evaluates to is the focus for the following expression, <em>span</em> .</p>
<p>The focus can be accessed using the context item expression, i.e., dot (&#8221;.&#8221;).</p>
<p>By default, the focus is not set and is undefined. It will therefore result in a dynamic error, <tt class="docutils literal"><span class="pre">XPDY0002</span></tt> , if the focus is attempted to be accessed. The focus must be set before the query is set with <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> .</p>
<p>There is no behavior defined for setting an item which is null.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setFocus</tt><big>(</big><em>documentURI</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>documentURI</strong> &#8211; <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Sets the focus to be the document located at <tt class="docutils literal"><span class="pre">documentURI</span></tt> and returns true. If <tt class="docutils literal"><span class="pre">documentURI</span></tt> cannot be loaded, false is returned. It is undefined at what time the document may be loaded. When loading the document, the message handler and URI resolver set on this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> are used.</p>
<p>If <tt class="docutils literal"><span class="pre">documentURI</span></tt> is empty or is not a valid URI, the behavior of this function is undefined.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setFocus</tt><big>(</big><em>document</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>document</strong> &#8211; <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Sets the focus to be the <tt class="docutils literal"><span class="pre">document</span></tt> read from the <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> and returns true. If <tt class="docutils literal"><span class="pre">document</span></tt> cannot be loaded, false is returned.</p>
<p><a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> does not take ownership of <tt class="docutils literal"><span class="pre">document</span></tt> . The user guarantees that a document is available from the <tt class="docutils literal"><span class="pre">document</span></tt> device and that the document is not empty. The device must be opened in at least read-only mode. <tt class="docutils literal"><span class="pre">document</span></tt> must stay in scope as long as the current query is active.</p>
<p>This is an overloaded function.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setFocus</tt><big>(</big><em>focus</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>focus</strong> &#8211; unicode</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>This function behaves identically to calling the <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setFocus"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setFocus()</span></tt></a> overload with a <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> whose content is <tt class="docutils literal"><span class="pre">focus</span></tt> encoded as UTF-8. That is, <tt class="docutils literal"><span class="pre">focus</span></tt> is treated as if it contained an XML document.</p>
<p>Returns the same result as the overload.</p>
<p>This is an overloaded function.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setInitialTemplateName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setInitialTemplateName" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.QXmlName" title="PySide.QtXmlPatterns.QXmlName"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlName</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the <tt class="docutils literal"><span class="pre">name</span></tt> of the initial template. The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</p>
<p>This function only applies when using <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> .</p>
<p>If the stylesheet has no template named <tt class="docutils literal"><span class="pre">name</span></tt> , the processor will use the standard order of template invocation.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.initialTemplateName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setInitialTemplateName</tt><big>(</big><em>name</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> &#8211; unicode</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Sets the name of the initial template to <tt class="docutils literal"><span class="pre">localName</span></tt> , which must be a valid <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.localName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.localName"><tt class="xref py py-meth docutils literal"><span class="pre">local</span> <span class="pre">name</span></tt></a> . The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</p>
<p>This function only applies when using <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> .</p>
<p>If <tt class="docutils literal"><span class="pre">localName</span></tt> is not a valid <a class="reference internal" href="QXmlName.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.localName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlName.localName"><tt class="xref py py-meth docutils literal"><span class="pre">local</span> <span class="pre">name</span></tt></a> , the effect is undefined. If the stylesheet has no template named <tt class="docutils literal"><span class="pre">localName</span></tt> , the processor will use the standard order of template invocation.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.initialTemplateName"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.initialTemplateName()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setMessageHandler">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setMessageHandler</tt><big>(</big><em>messageHandler</em><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setMessageHandler" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>messageHandler</strong> &#8211; <a class="reference internal" href="QAbstractMessageHandler.html#PySide.QtXmlPatterns.QAbstractMessageHandler" title="PySide.QtXmlPatterns.QAbstractMessageHandler"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractMessageHandler</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Changes the <a class="reference internal" href="QAbstractMessageHandler.html#PySide.QtXmlPatterns.QAbstractMessageHandler" title="PySide.QtXmlPatterns.QAbstractMessageHandler"><tt class="xref py py-class docutils literal"><span class="pre">message</span> <span class="pre">handler</span></tt></a> for this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to <tt class="docutils literal"><span class="pre">aMessageHandler</span></tt> . The query sends all compile and runtime messages to this message handler. <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> does not take ownership of <tt class="docutils literal"><span class="pre">aMessageHandler</span></tt> .</p>
<p>Normally, the default message handler is sufficient. It writes compile and runtime messages to <em>stderr</em> . The default message handler includes color codes if <em>stderr</em> can render colors.</p>
<p>Note that changing the message handler after the query has been compiled has no effect, i.e. the query uses the same message handler at runtime that it uses at compile time.</p>
<p>When <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> calls <a class="reference internal" href="QAbstractMessageHandler.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QAbstractMessageHandler.message" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QAbstractMessageHandler.message"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractMessageHandler.message()</span></tt></a> , the arguments are as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>message() argument</td>
<td>Semantics</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-attr docutils literal"><span class="pre">QtMsgType</span></tt> type</td>
<td>Only <tt class="xref py py-attr docutils literal"><span class="pre">QtWarningMsg</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">QtFatalMsg</span></tt> are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</td>
</tr>
<tr class="row-odd"><td>const <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QString</span></tt> &amp; description</td>
<td>An XHTML document which is the actual message. It is translated into the current language.</td>
</tr>
<tr class="row-even"><td>const <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a> &amp;identifier</td>
<td>Identifies the error with a URI, where the fragment is the error code, and the rest of the URI is the error namespace.</td>
</tr>
<tr class="row-odd"><td>const <a class="reference internal" href="QSourceLocation.html#PySide.QtXmlPatterns.QSourceLocation" title="PySide.QtXmlPatterns.QSourceLocation"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QSourceLocation</span></tt></a> &amp; sourceLocation</td>
<td>Identifies where the error occurred.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.messageHandler()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setNetworkAccessManager">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setNetworkAccessManager</tt><big>(</big><em>newManager</em><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setNetworkAccessManager" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newManager</strong> &#8211; <a class="reference internal" href="../QtNetwork/QNetworkAccessManager.html#PySide.QtNetwork.QNetworkAccessManager" title="PySide.QtNetwork.QNetworkAccessManager"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QNetworkAccessManager</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the network manager to <tt class="docutils literal"><span class="pre">newManager</span></tt> . <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> does not take ownership of <tt class="docutils literal"><span class="pre">newManager</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.networkAccessManager" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.networkAccessManager"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.networkAccessManager()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setQuery</tt><big>(</big><em>queryURI</em><span class="optional">[</span>, <em>baseURI=QUrl()</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>queryURI</strong> &#8211; <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a></li>
<li><strong>baseURI</strong> &#8211; <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Sets this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to the <em class="xref std std-ref">XQuery</em> read from the <tt class="docutils literal"><span class="pre">queryURI</span></tt> . Use <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.isValid()</span></tt></a> after calling this function. If an error occurred reading <tt class="docutils literal"><span class="pre">queryURI</span></tt> , e.g., the query does not exist, cannot be read, or is invalid, <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.isValid()</span></tt></a> will return <em>false</em> .</p>
<p>The supported URI schemes are the same as those in the <em class="xref std std-ref">XQuery</em> function <tt class="docutils literal"><span class="pre">fn:doc</span></tt> , except that queryURI can be the object of a variable binding.</p>
<p><tt class="docutils literal"><span class="pre">baseURI</span></tt> is the Base URI of the static context, as defined in the <em class="xref std std-ref">XQuery</em> language. It is used internally to resolve relative URIs that appear in the query, and for message reporting. If <tt class="docutils literal"><span class="pre">baseURI</span></tt> is empty, <tt class="docutils literal"><span class="pre">queryURI</span></tt> is used. Otherwise, <tt class="docutils literal"><span class="pre">baseURI</span></tt> is used, and it is resolved against the <tt class="xref py py-meth docutils literal"><span class="pre">application</span> <span class="pre">file</span> <span class="pre">path</span></tt> if it is relative.</p>
<p>If <tt class="docutils literal"><span class="pre">queryURI</span></tt> is empty or invalid, or if <tt class="docutils literal"><span class="pre">baseURI</span></tt> is invalid, the behavior of this function is undefined.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setQuery</tt><big>(</big><em>sourceCode</em><span class="optional">[</span>, <em>documentURI=QUrl()</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sourceCode</strong> &#8211; unicode</li>
<li><strong>documentURI</strong> &#8211; <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>The behavior and requirements of this function are the same as for setQuery( <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> *, const <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a> &amp;), after the <em class="xref std std-ref">XQuery</em> has been read from the IO device into a string. Because <tt class="docutils literal"><span class="pre">sourceCode</span></tt> is already a Unicode string, detection of its encoding is unnecessary.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setQuery</tt><big>(</big><em>sourceCode</em><span class="optional">[</span>, <em>documentURI=QUrl()</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sourceCode</strong> &#8211; <a class="reference internal" href="../QtCore/QIODevice.html#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a></li>
<li><strong>documentURI</strong> &#8211; <a class="reference internal" href="../QtCore/QUrl.html#PySide.QtCore.QUrl" title="PySide.QtCore.QUrl"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QUrl</span></tt></a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Sets this <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> to an <em class="xref std std-ref">XQuery</em> read from the <tt class="docutils literal"><span class="pre">sourceCode</span></tt> device. The device must have been opened with at least <tt class="xref py py-attr docutils literal"><span class="pre">QIODevice.ReadOnly</span></tt> .</p>
<p><tt class="docutils literal"><span class="pre">documentURI</span></tt> represents the query obtained from the <tt class="docutils literal"><span class="pre">sourceCode</span></tt> device. It is the base URI of the static context, as defined in the <em class="xref std std-ref">XQuery</em> language. It is used internally to resolve relative URIs that appear in the query, and for message reporting. <tt class="docutils literal"><span class="pre">documentURI</span></tt> can be empty. If it is empty, the <tt class="xref py py-meth docutils literal"><span class="pre">application</span> <span class="pre">file</span> <span class="pre">path</span></tt> is used. If it is not empty, it may be either relative or absolute. If it is relative, it is resolved itself against the <tt class="xref py py-meth docutils literal"><span class="pre">application</span> <span class="pre">file</span> <span class="pre">path</span></tt> before it is used. If <tt class="docutils literal"><span class="pre">documentURI</span></tt> is neither a valid URI nor empty, the result is undefined.</p>
<p>If the query contains a static error (e.g. syntax error), an error message is sent to the <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.messageHandler"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.messageHandler()</span></tt></a> , and <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.isValid()</span></tt></a> will return <em>false</em> .</p>
<p>Variables must be bound before <a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setQuery"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setQuery()</span></tt></a> is called.</p>
<p>The encoding of the <em class="xref std std-ref">XQuery</em> in <tt class="docutils literal"><span class="pre">sourceCode</span></tt> is detected internally using the rules for setting and detecting encoding of <em class="xref std std-ref">XQuery</em> files, which are explained in the <em class="xref std std-ref">XQuery</em> language.</p>
<p>If <tt class="docutils literal"><span class="pre">sourceCode</span></tt> is <tt class="docutils literal"><span class="pre">null</span></tt> or not readable, or if <tt class="docutils literal"><span class="pre">documentURI</span></tt> is not a valid URI, behavior is undefined.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.isValid"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.isValid()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setUriResolver">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">setUriResolver</tt><big>(</big><em>resolver</em><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setUriResolver" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>resolver</strong> &#8211; <a class="reference internal" href="QAbstractUriResolver.html#PySide.QtXmlPatterns.QAbstractUriResolver" title="PySide.QtXmlPatterns.QAbstractUriResolver"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractUriResolver</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Sets the URI resolver to <tt class="docutils literal"><span class="pre">resolver</span></tt> . <a class="reference internal" href="#PySide.QtXmlPatterns.QXmlQuery" title="PySide.QtXmlPatterns.QXmlQuery"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery</span></tt></a> does not take ownership of <tt class="docutils literal"><span class="pre">resolver</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.uriResolver" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.uriResolver"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.uriResolver()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.uriResolver">
<tt class="descclassname">PySide.QtXmlPatterns.QXmlQuery.</tt><tt class="descname">uriResolver</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.uriResolver" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QAbstractUriResolver.html#PySide.QtXmlPatterns.QAbstractUriResolver" title="PySide.QtXmlPatterns.QAbstractUriResolver"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtXmlPatterns.QAbstractUriResolver</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Returns the query&#8217;s URI resolver. If no URI resolver has been set, <em class="xref std std-ref">QtXmlPatterns</em> will use the URIs in queries as they are.</p>
<p>The URI resolver provides a level of abstraction, or <em>polymorphic URIs</em> . A resolver can rewrite <em>logical</em> URIs to physical ones, or it can translate obsolete or invalid URIs to valid ones.</p>
<p><em class="xref std std-ref">QtXmlPatterns</em> calls the URI resolver for all URIs it encounters, except for namespaces. Specifically, all builtin functions that deal with URIs (<tt class="docutils literal"><span class="pre">fn:doc()</span></tt> , and <tt class="docutils literal"><span class="pre">fn:doc-available()</span></tt> ).</p>
<p>In the case of <tt class="docutils literal"><span class="pre">fn:doc()</span></tt> , the absolute URI is the base URI in the static context (which most likely is the location of the query). Rather than use the URI the user specified, the return value of <a class="reference internal" href="QAbstractUriResolver.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QAbstractUriResolver.resolve" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QAbstractUriResolver.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractUriResolver.resolve()</span></tt></a> will be used.</p>
<p>When <em class="xref std std-ref">QtXmlPatterns</em> calls <a class="reference internal" href="QAbstractUriResolver.html#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QAbstractUriResolver.resolve" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QAbstractUriResolver.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">QAbstractUriResolver.resolve()</span></tt></a> the absolute URI is the URI mandated by the <em class="xref std std-ref">XQuery</em> language, and the relative URI is the URI specified by the user.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setUriResolver" title="PySide.QtXmlPatterns.PySide.QtXmlPatterns.QXmlQuery.setUriResolver"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtXmlPatterns.QXmlQuery.setUriResolver()</span></tt></a></p>
</div>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>