<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QIODevice &mdash; PySide 1.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.2.1 documentation" href="../../index.html" />
    <link rel="up" title="PySide.QtCore" href="index.html" />
    <link rel="next" title="QBuffer" href="QBuffer.html" />
    <link rel="prev" title="QThread" href="QThread.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.2.1 documentation</a></li>
                <li> &raquo; <a href="../../modules.html" >PySide modules</a></li>
                <li> &raquo; <a href="index.html" accesskey="U">PySide.QtCore</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QIODevice</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#virtual-functions">Virtual functions</a></li>
<li><a class="reference internal" href="#signals">Signals</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QThread.html"
                        title="previous chapter">QThread</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QBuffer.html"
                        title="next chapter">QBuffer</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtCore"></span><div class="section" id="qiodevice">
<span id="id1"></span><h1>QIODevice<a class="headerlink" href="#qiodevice" title="Permalink to this headline">¶</a></h1>
<p><strong>Inherited by:</strong> <a class="reference internal" href="../QtNetwork/QNetworkReply.html#qnetworkreply"><em>QNetworkReply</em></a>, <a class="reference internal" href="QBuffer.html#qbuffer"><em>QBuffer</em></a>, <a class="reference internal" href="../QtNetwork/QAbstractSocket.html#qabstractsocket"><em>QAbstractSocket</em></a>, <a class="reference internal" href="../QtNetwork/QUdpSocket.html#qudpsocket"><em>QUdpSocket</em></a>, <a class="reference internal" href="../QtNetwork/QLocalSocket.html#qlocalsocket"><em>QLocalSocket</em></a>, <a class="reference internal" href="QFile.html#qfile"><em>QFile</em></a>, <a class="reference internal" href="QTemporaryFile.html#qtemporaryfile"><em>QTemporaryFile</em></a>, <a class="reference internal" href="QProcess.html#qprocess"><em>QProcess</em></a>, <a class="reference internal" href="../QtNetwork/QTcpSocket.html#qtcpsocket"><em>QTcpSocket</em></a>, <a class="reference internal" href="../QtNetwork/QSslSocket.html#qsslsocket"><em>QSslSocket</em></a></p>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.errorString" title="PySide.QtCore.PySide.QtCore.QIODevice.errorString"><tt class="xref py py-meth docutils literal"><span class="pre">errorString</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.getChar" title="PySide.QtCore.PySide.QtCore.QIODevice.getChar"><tt class="xref py py-meth docutils literal"><span class="pre">getChar</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isOpen" title="PySide.QtCore.PySide.QtCore.QIODevice.isOpen"><tt class="xref py py-meth docutils literal"><span class="pre">isOpen</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isReadable" title="PySide.QtCore.PySide.QtCore.QIODevice.isReadable"><tt class="xref py py-meth docutils literal"><span class="pre">isReadable</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isTextModeEnabled" title="PySide.QtCore.PySide.QtCore.QIODevice.isTextModeEnabled"><tt class="xref py py-meth docutils literal"><span class="pre">isTextModeEnabled</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isWritable" title="PySide.QtCore.PySide.QtCore.QIODevice.isWritable"><tt class="xref py py-meth docutils literal"><span class="pre">isWritable</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.openMode" title="PySide.QtCore.PySide.QtCore.QIODevice.openMode"><tt class="xref py py-meth docutils literal"><span class="pre">openMode</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.peek" title="PySide.QtCore.PySide.QtCore.QIODevice.peek"><tt class="xref py py-meth docutils literal"><span class="pre">peek</span></tt></a> (maxlen)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.putChar" title="PySide.QtCore.PySide.QtCore.QIODevice.putChar"><tt class="xref py py-meth docutils literal"><span class="pre">putChar</span></tt></a> (c)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">read</span></tt></a> (maxlen)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readAll" title="PySide.QtCore.PySide.QtCore.QIODevice.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">readAll</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">readLine</span></tt></a> ([maxlen=0])</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setErrorString" title="PySide.QtCore.PySide.QtCore.QIODevice.setErrorString"><tt class="xref py py-meth docutils literal"><span class="pre">setErrorString</span></tt></a> (errorString)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode" title="PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode"><tt class="xref py py-meth docutils literal"><span class="pre">setOpenMode</span></tt></a> (openMode)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setTextModeEnabled" title="PySide.QtCore.PySide.QtCore.QIODevice.setTextModeEnabled"><tt class="xref py py-meth docutils literal"><span class="pre">setTextModeEnabled</span></tt></a> (enabled)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.ungetChar" title="PySide.QtCore.PySide.QtCore.QIODevice.ungetChar"><tt class="xref py py-meth docutils literal"><span class="pre">ungetChar</span></tt></a> (c)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.write" title="PySide.QtCore.PySide.QtCore.QIODevice.write"><tt class="xref py py-meth docutils literal"><span class="pre">write</span></tt></a> (data)</li>
</ul>
</div>
<div class="section" id="virtual-functions">
<h3>Virtual functions<a class="headerlink" href="#virtual-functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.atEnd" title="PySide.QtCore.PySide.QtCore.QIODevice.atEnd"><tt class="xref py py-meth docutils literal"><span class="pre">atEnd</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">bytesAvailable</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite"><tt class="xref py py-meth docutils literal"><span class="pre">bytesToWrite</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.canReadLine" title="PySide.QtCore.PySide.QtCore.QIODevice.canReadLine"><tt class="xref py py-meth docutils literal"><span class="pre">canReadLine</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.close" title="PySide.QtCore.PySide.QtCore.QIODevice.close"><tt class="xref py py-meth docutils literal"><span class="pre">close</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">isSequential</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.open" title="PySide.QtCore.PySide.QtCore.QIODevice.open"><tt class="xref py py-meth docutils literal"><span class="pre">open</span></tt></a> (mode)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.pos" title="PySide.QtCore.PySide.QtCore.QIODevice.pos"><tt class="xref py py-meth docutils literal"><span class="pre">pos</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readData" title="PySide.QtCore.PySide.QtCore.QIODevice.readData"><tt class="xref py py-meth docutils literal"><span class="pre">readData</span></tt></a> (, maxlen)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLineData" title="PySide.QtCore.PySide.QtCore.QIODevice.readLineData"><tt class="xref py py-meth docutils literal"><span class="pre">readLineData</span></tt></a> (, maxlen)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.reset" title="PySide.QtCore.PySide.QtCore.QIODevice.reset"><tt class="xref py py-meth docutils literal"><span class="pre">reset</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.seek" title="PySide.QtCore.PySide.QtCore.QIODevice.seek"><tt class="xref py py-meth docutils literal"><span class="pre">seek</span></tt></a> (pos)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.size" title="PySide.QtCore.PySide.QtCore.QIODevice.size"><tt class="xref py py-meth docutils literal"><span class="pre">size</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">waitForBytesWritten</span></tt></a> (msecs)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead"><tt class="xref py py-meth docutils literal"><span class="pre">waitForReadyRead</span></tt></a> (msecs)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.writeData" title="PySide.QtCore.PySide.QtCore.QIODevice.writeData"><tt class="xref py py-meth docutils literal"><span class="pre">writeData</span></tt></a> (data, len)</li>
</ul>
</div>
<div class="section" id="signals">
<h3>Signals<a class="headerlink" href="#signals" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.aboutToClose" title="PySide.QtCore.PySide.QtCore.QIODevice.aboutToClose"><tt class="xref py py-meth docutils literal"><span class="pre">aboutToClose</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">bytesWritten</span></tt></a> (bytes)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readChannelFinished" title="PySide.QtCore.PySide.QtCore.QIODevice.readChannelFinished"><tt class="xref py py-meth docutils literal"><span class="pre">readChannelFinished</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">readyRead</span></tt></a> ()</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> class is the base interface class of all I/O devices in Qt.</p>
<p><a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> provides both a common implementation and an abstract interface for devices that support reading and writing of blocks of data, such as <a class="reference internal" href="QFile.html#PySide.QtCore.QFile" title="PySide.QtCore.QFile"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QFile</span></tt></a> , <a class="reference internal" href="QBuffer.html#PySide.QtCore.QBuffer" title="PySide.QtCore.QBuffer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QBuffer</span></tt></a> and <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> . <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> is abstract and can not be instantiated, but it is common to use the interface it defines to provide device-independent I/O features. For example, Qt&#8217;s XML classes operate on a <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> pointer, allowing them to be used with various devices (such as files and buffers).</p>
<p>Before accessing the device, <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.open" title="PySide.QtCore.PySide.QtCore.QIODevice.open"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.open()</span></tt></a> must be called to set the correct <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt> (such as <tt class="xref py py-attr docutils literal"><span class="pre">ReadOnly</span></tt> or <tt class="xref py py-attr docutils literal"><span class="pre">ReadWrite</span></tt> ). You can then write to the device with <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.write" title="PySide.QtCore.PySide.QtCore.QIODevice.write"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt></a> or <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.putChar" title="PySide.QtCore.PySide.QtCore.QIODevice.putChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.putChar()</span></tt></a> , and read by calling either <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a> , <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt></a> , or <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readAll" title="PySide.QtCore.PySide.QtCore.QIODevice.readAll"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readAll()</span></tt></a> . Call <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.close" title="PySide.QtCore.PySide.QtCore.QIODevice.close"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.close()</span></tt></a> when you are done with the device.</p>
<p><a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> distinguishes between two types of devices: random-access devices and sequential devices.</p>
<ul class="simple">
<li>Random-access devices support seeking to arbitrary positions using <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.seek" title="PySide.QtCore.PySide.QtCore.QIODevice.seek"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.seek()</span></tt></a> . The current position in the file is available by calling <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.pos" title="PySide.QtCore.PySide.QtCore.QIODevice.pos"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.pos()</span></tt></a> . <a class="reference internal" href="QFile.html#PySide.QtCore.QFile" title="PySide.QtCore.QFile"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QFile</span></tt></a> and <a class="reference internal" href="QBuffer.html#PySide.QtCore.QBuffer" title="PySide.QtCore.QBuffer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QBuffer</span></tt></a> are examples of random-access devices.</li>
<li>Sequential devices don&#8217;t support seeking to arbitrary positions. The data must be read in one pass. The functions <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.pos" title="PySide.QtCore.PySide.QtCore.QIODevice.pos"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.pos()</span></tt></a> and <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.size" title="PySide.QtCore.PySide.QtCore.QIODevice.size"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.size()</span></tt></a> don&#8217;t work for sequential devices. <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> and <a class="reference internal" href="QProcess.html#PySide.QtCore.QProcess" title="PySide.QtCore.QProcess"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QProcess</span></tt></a> are examples of sequential devices.</li>
</ul>
<p>You can use <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isSequential()</span></tt></a> to determine the type of device.</p>
<p><a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> emits <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a> when new data is available for reading; for example, if new data has arrived on the network or if additional data is appended to a file that you are reading from. You can call <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesAvailable()</span></tt></a> to determine the number of bytes that are currently available for reading. It&#8217;s common to use <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesAvailable()</span></tt></a> together with the <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a> signal when programming with asynchronous devices such as <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> , where fragments of data can arrive at arbitrary points in time. <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> emits the <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesWritten()</span></tt></a> signal every time a payload of data has been written to the device. Use <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesToWrite()</span></tt></a> to determine the current amount of data waiting to be written.</p>
<p>Certain subclasses of <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> , such as <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> and <a class="reference internal" href="QProcess.html#PySide.QtCore.QProcess" title="PySide.QtCore.QProcess"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QProcess</span></tt></a> , are asynchronous. This means that I/O functions such as <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.write" title="PySide.QtCore.PySide.QtCore.QIODevice.write"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt></a> or <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a> always return immediately, while communication with the device itself may happen when control goes back to the event loop. <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> provides functions that allow you to force these operations to be performed immediately, while blocking the calling thread and without entering the event loop. This allows <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> subclasses to be used without an event loop, or in a separate thread:</p>
<ul class="simple">
<li><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.waitForReadyRead()</span></tt></a> - This function suspends operation in the calling thread until new data is available for reading.</li>
<li><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.waitForBytesWritten()</span></tt></a> - This function suspends operation in the calling thread until one payload of data has been written to the device.</li>
<li>waitFor....() - Subclasses of <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> implement blocking functions for device-specific operations. For example, <a class="reference internal" href="QProcess.html#PySide.QtCore.QProcess" title="PySide.QtCore.QProcess"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QProcess</span></tt></a> has a function called waitForStarted() which suspends operation in the calling thread until the process has started.</li>
</ul>
<p>Calling these functions from the main, GUI thread, may cause your user interface to freeze. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gzip</span> <span class="o">=</span> <span class="n">QProcess</span><span class="p">()</span>
<span class="n">gzip</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s">&quot;gzip&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;-c&quot;</span><span class="p">])</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">gzip</span><span class="o">.</span><span class="n">waitForStarted</span><span class="p">():</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="n">gzip</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;uncompressed data&quot;</span><span class="p">)</span>

<span class="n">compressed</span> <span class="o">=</span> <span class="n">QByteArray</span><span class="p">()</span>
<span class="k">while</span> <span class="n">gzip</span><span class="o">.</span><span class="n">waitForReadyRead</span><span class="p">():</span>
    <span class="n">compressed</span> <span class="o">+=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">readAll</span><span class="p">()</span>
</pre></div>
</div>
<p>By subclassing <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> , you can provide the same interface to your own I/O devices. Subclasses of <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> are only required to implement the protected <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readData" title="PySide.QtCore.PySide.QtCore.QIODevice.readData"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readData()</span></tt></a> and <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.writeData" title="PySide.QtCore.PySide.QtCore.QIODevice.writeData"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.writeData()</span></tt></a> functions. <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> uses these functions to implement all its convenience functions, such as <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.getChar" title="PySide.QtCore.PySide.QtCore.QIODevice.getChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.getChar()</span></tt></a> , <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt></a> and <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.write" title="PySide.QtCore.PySide.QtCore.QIODevice.write"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt></a> . <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> also handles access control for you, so you can safely assume that the device is opened in write mode if <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.writeData" title="PySide.QtCore.PySide.QtCore.QIODevice.writeData"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.writeData()</span></tt></a> is called.</p>
<p>Some subclasses, such as <a class="reference internal" href="QFile.html#PySide.QtCore.QFile" title="PySide.QtCore.QFile"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QFile</span></tt></a> and <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> , are implemented using a memory buffer for intermediate storing of data. This reduces the number of required device accessing calls, which are often very slow. Buffering makes functions like <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.getChar" title="PySide.QtCore.PySide.QtCore.QIODevice.getChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.getChar()</span></tt></a> and <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.putChar" title="PySide.QtCore.PySide.QtCore.QIODevice.putChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.putChar()</span></tt></a> fast, as they can operate on the memory buffer instead of directly on the device itself. Certain I/O operations, however, don&#8217;t work well with a buffer. For example, if several users open the same device and read it character by character, they may end up reading the same data when they meant to read a separate chunk each. For this reason, <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> allows you to bypass any buffering by passing the Unbuffered flag to <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.open" title="PySide.QtCore.PySide.QtCore.QIODevice.open"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.open()</span></tt></a> . When subclassing <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> , remember to bypass any buffer you may use when the device is open in Unbuffered mode.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QBuffer.html#PySide.QtCore.QBuffer" title="PySide.QtCore.QBuffer"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QBuffer</span></tt></a>  <a class="reference internal" href="QFile.html#PySide.QtCore.QFile" title="PySide.QtCore.QFile"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QFile</span></tt></a>  <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide.QtCore.QIODevice">
<em class="property">class </em><tt class="descclassname">PySide.QtCore.</tt><tt class="descname">QIODevice</tt><a class="headerlink" href="#PySide.QtCore.QIODevice" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property">class </em><tt class="descclassname">PySide.QtCore.</tt><tt class="descname">QIODevice</tt><big>(</big><em>parent</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parent</strong> &#8211; <a class="reference internal" href="QObject.html#PySide.QtCore.QObject" title="PySide.QtCore.QObject"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QObject</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Constructs a <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> object.</p>
<p>Constructs a <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> object with the given <tt class="docutils literal"><span class="pre">parent</span></tt> .</p>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.OpenModeFlag">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">OpenModeFlag</tt><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.OpenModeFlag" title="Permalink to this definition">¶</a></dt>
<dd><p>This enum is used with <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.open" title="PySide.QtCore.PySide.QtCore.QIODevice.open"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.open()</span></tt></a> to describe the mode in which a device is opened. It is also returned by <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.openMode" title="PySide.QtCore.PySide.QtCore.QIODevice.openMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.openMode()</span></tt></a> .</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QIODevice.NotOpen</td>
<td>The device is not open.</td>
</tr>
<tr class="row-odd"><td>QIODevice.ReadOnly</td>
<td>The device is open for reading.</td>
</tr>
<tr class="row-even"><td>QIODevice.WriteOnly</td>
<td>The device is open for writing.</td>
</tr>
<tr class="row-odd"><td>QIODevice.ReadWrite</td>
<td>The device is open for reading and writing.</td>
</tr>
<tr class="row-even"><td>QIODevice.Append</td>
<td>The device is opened in append mode, so that all data is written to the end of the file.</td>
</tr>
<tr class="row-odd"><td>QIODevice.Truncate</td>
<td>If possible, the device is truncated before it is opened. All earlier contents of the device are lost.</td>
</tr>
<tr class="row-even"><td>QIODevice.Text</td>
<td>When reading, the end-of-line terminators are translated to &#8216;n&#8217;. When writing, the end-of-line terminators are translated to the local encoding, for example &#8216;rn&#8217; for Win32.</td>
</tr>
<tr class="row-odd"><td>QIODevice.Unbuffered</td>
<td>Any buffer in the device is bypassed.</td>
</tr>
</tbody>
</table>
<p>Certain flags, such as <tt class="docutils literal"><span class="pre">Unbuffered</span></tt> and <tt class="docutils literal"><span class="pre">Truncate</span></tt> , are meaningless when used with some subclasses. Some of these restrictions are implied by the type of device that is represented by a subclass. In other cases, the restriction may be due to the implementation, or may be imposed by the underlying platform; for example, <a class="reference internal" href="../QtNetwork/QTcpSocket.html#PySide.QtNetwork.QTcpSocket" title="PySide.QtNetwork.QTcpSocket"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtNetwork.QTcpSocket</span></tt></a> does not support <tt class="docutils literal"><span class="pre">Unbuffered</span></tt> mode, and limitations in the native API prevent <a class="reference internal" href="QFile.html#PySide.QtCore.QFile" title="PySide.QtCore.QFile"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QFile</span></tt></a> from supporting <tt class="docutils literal"><span class="pre">Unbuffered</span></tt> on Windows.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.aboutToClose">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">aboutToClose</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.aboutToClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.atEnd">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">atEnd</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.atEnd" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the current read and write position is at the end of the device (i.e. there is no more data available for reading on the device); otherwise returns false.</p>
<p>For some devices, <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.atEnd" title="PySide.QtCore.PySide.QtCore.QIODevice.atEnd"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.atEnd()</span></tt></a> can return true even though there is more data to read. This special case only applies to devices that generate data in direct response to you calling <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a> (e.g., <tt class="docutils literal"><span class="pre">/dev</span></tt> or <tt class="docutils literal"><span class="pre">/proc</span></tt> files on Unix and Mac OS X, or console input / <tt class="docutils literal"><span class="pre">stdin</span></tt> on all platforms).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesAvailable()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isSequential()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">bytesAvailable</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the number of bytes that are available for reading. This function is commonly used with sequential devices to determine the number of bytes to allocate in a buffer before reading.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the size of QIODevices&#8217; buffer. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">bytesAvailable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">QIODevice</span><span class="o">.</span><span class="n">bytesAvailable</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesToWrite()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isSequential()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">bytesToWrite</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesToWrite" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>For buffered devices, this function returns the number of bytes waiting to be written. For devices with no buffer, this function returns 0.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesAvailable()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesWritten()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isSequential()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">bytesWritten</tt><big>(</big><em>bytes</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bytes</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.canReadLine">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">canReadLine</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.canReadLine" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if a complete line of data can be read from the device; otherwise returns false.</p>
<p>Note that unbuffered devices, which have no way of determining what can be read, always return false.</p>
<p>This function is often called in conjunction with the <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a> signal.</p>
<p>Subclasses that reimplement this function must call the base implementation in order to include the contents of the <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> &#8216;s buffer. Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">canReadLine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">QIODevice</span><span class="o">.</span><span class="n">canReadLine</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.close">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.close" title="Permalink to this definition">¶</a></dt>
<dd><p>First emits <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.aboutToClose" title="PySide.QtCore.PySide.QtCore.QIODevice.aboutToClose"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.aboutToClose()</span></tt></a> , then closes the device and sets its <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt> to <tt class="xref py py-attr docutils literal"><span class="pre">NotOpen</span></tt> . The error string is also reset.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode" title="PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.setOpenMode()</span></tt></a>  <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.errorString">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">errorString</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.errorString" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">unicode</td>
</tr>
</tbody>
</table>
<p>Returns a human-readable description of the last device error that occurred.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setErrorString" title="PySide.QtCore.PySide.QtCore.QIODevice.setErrorString"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.setErrorString()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.getChar">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">getChar</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.getChar" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Reads one character from the device and stores it in <tt class="docutils literal"><span class="pre">c</span></tt> . If <tt class="docutils literal"><span class="pre">c</span></tt> is 0, the character is discarded. Returns true on success; otherwise returns false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.putChar" title="PySide.QtCore.PySide.QtCore.QIODevice.putChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.putChar()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.ungetChar" title="PySide.QtCore.PySide.QtCore.QIODevice.ungetChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.ungetChar()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.isOpen">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">isOpen</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.isOpen" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the device is open; otherwise returns false. A device is open if it can be read from and/or written to. By default, this function returns false if <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.openMode" title="PySide.QtCore.PySide.QtCore.QIODevice.openMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.openMode()</span></tt></a> returns <tt class="docutils literal"><span class="pre">NotOpen</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.openMode" title="PySide.QtCore.PySide.QtCore.QIODevice.openMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.openMode()</span></tt></a>  <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.isReadable">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">isReadable</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.isReadable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if data can be read from the device; otherwise returns false. Use <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesAvailable()</span></tt></a> to determine how many bytes can be read.</p>
<p>This is a convenience function which checks if the <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt> of the device contains the <tt class="xref py py-attr docutils literal"><span class="pre">ReadOnly</span></tt> flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.openMode" title="PySide.QtCore.PySide.QtCore.QIODevice.openMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.openMode()</span></tt></a>  <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.isSequential">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">isSequential</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if this device is sequential; otherwise returns false.</p>
<p>Sequential devices, as opposed to a random-access devices, have no concept of a start, an end, a size, or a current position, and they do not support seeking. You can only read from the device when it reports that data is available. The most common example of a sequential device is a network socket. On Unix, special files such as /dev/zero and fifo pipes are sequential.</p>
<p>Regular files, on the other hand, do support random access. They have both a size and a current position, and they also support seeking backwards and forwards in the data stream. Regular files are non-sequential.</p>
<p>The <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> implementation returns false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesAvailable()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.isTextModeEnabled">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">isTextModeEnabled</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.isTextModeEnabled" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if the <tt class="xref py py-attr docutils literal"><span class="pre">Text</span></tt> flag is enabled; otherwise returns false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setTextModeEnabled" title="PySide.QtCore.PySide.QtCore.QIODevice.setTextModeEnabled"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.setTextModeEnabled()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.isWritable">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">isWritable</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.isWritable" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns true if data can be written to the device; otherwise returns false.</p>
<p>This is a convenience function which checks if the <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt> of the device contains the <tt class="xref py py-attr docutils literal"><span class="pre">WriteOnly</span></tt> flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.openMode" title="PySide.QtCore.PySide.QtCore.QIODevice.openMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.openMode()</span></tt></a>  <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.open">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">open</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.open" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice.OpenMode</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.openMode">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">openMode</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.openMode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice.OpenMode</span></tt></td>
</tr>
</tbody>
</table>
<p>Returns the mode in which the device has been opened; i.e. <tt class="xref py py-attr docutils literal"><span class="pre">ReadOnly</span></tt> or <tt class="xref py py-attr docutils literal"><span class="pre">WriteOnly</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode" title="PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.setOpenMode()</span></tt></a>  <tt class="xref py py-class docutils literal"><span class="pre">OpenMode</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.peek">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">peek</tt><big>(</big><em>maxlen</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.peek" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxlen</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Peeks at most <tt class="docutils literal"><span class="pre">maxSize</span></tt> bytes from the device, returning the data peeked as a <a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a> .</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">isExeFile</span><span class="p">(</span><span class="n">file_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">file_</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MZ&quot;</span>
</pre></div>
</div>
<p>This function has no way of reporting errors; returning an empty <tt class="xref py py-meth docutils literal"><span class="pre">QByteArray()</span></tt> can mean either that no data was currently available for peeking, or that an error occurred.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.pos">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">pos</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.pos" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>For random-access devices, this function returns the position that data is written to or read from. For sequential devices or closed devices, where there is no concept of a &#8220;current position&#8221;, 0 is returned.</p>
<p>The current read/write position of the device is maintained internally by <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> , so reimplementing this function is not necessary. When subclassing <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> , use <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.seek" title="PySide.QtCore.PySide.QtCore.QIODevice.seek"><tt class="xref py py-meth docutils literal"><span class="pre">QIODevice.seek()</span></tt></a> to notify <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> about changes in the device position.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isSequential()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.seek" title="PySide.QtCore.PySide.QtCore.QIODevice.seek"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.seek()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.putChar">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">putChar</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.putChar" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>c</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.char</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Writes the character <tt class="docutils literal"><span class="pre">c</span></tt> to the device. Returns true on success; otherwise returns false.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.write" title="PySide.QtCore.PySide.QtCore.QIODevice.write"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.getChar" title="PySide.QtCore.PySide.QtCore.QIODevice.getChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.getChar()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.ungetChar" title="PySide.QtCore.PySide.QtCore.QIODevice.ungetChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.ungetChar()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.read">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">read</tt><big>(</big><em>maxlen</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxlen</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Reads at most <tt class="docutils literal"><span class="pre">maxSize</span></tt> bytes from the device, and returns the data read as a <a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a> .</p>
<p>This function has no way of reporting errors; returning an empty <tt class="xref py py-meth docutils literal"><span class="pre">QByteArray()</span></tt> can mean either that no data was currently available for reading, or that an error occurred.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.readAll">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">readAll</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.readAll" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Reads all available data from the device, and returns it as a <a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a> .</p>
<p>This function has no way of reporting errors; returning an empty <tt class="xref py py-meth docutils literal"><span class="pre">QByteArray()</span></tt> can mean either that no data was currently available for reading, or that an error occurred.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.readChannelFinished">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">readChannelFinished</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.readChannelFinished" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.readData">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">readData</tt><big>(</big><em>maxlen</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.readData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxlen</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">PyObject</td>
</tr>
</tbody>
</table>
<p>Reads up to <tt class="docutils literal"><span class="pre">maxSize</span></tt> bytes from the device into <tt class="docutils literal"><span class="pre">data</span></tt> , and returns the number of bytes read or -1 if an error occurred.</p>
<p>If there are no bytes to be read and there can never be more bytes available (examples include socket closed, pipe closed, sub-process finished), this function returns -1.</p>
<p>This function is called by <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> . Reimplement this function when creating a subclass of <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> .</p>
<p>When reimplementing this function it is important that this function reads all the required data before returning. This is required in order for <a class="reference internal" href="QDataStream.html#PySide.QtCore.QDataStream" title="PySide.QtCore.QDataStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QDataStream</span></tt></a> to be able to operate on the class. <a class="reference internal" href="QDataStream.html#PySide.QtCore.QDataStream" title="PySide.QtCore.QDataStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QDataStream</span></tt></a> assumes all the requested information was read and therefore does not retry reading if there was a problem.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.writeData" title="PySide.QtCore.PySide.QtCore.QIODevice.writeData"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.writeData()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.readLine">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">readLine</tt><big>(</big><span class="optional">[</span><em>maxlen=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxlen</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Reads a line from the device, but no more than <tt class="docutils literal"><span class="pre">maxSize</span></tt> characters, and returns the result as a <a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a> .</p>
<p>This function has no way of reporting errors; returning an empty <tt class="xref py py-meth docutils literal"><span class="pre">QByteArray()</span></tt> can mean either that no data was currently available for reading, or that an error occurred.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.readLineData">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">readLineData</tt><big>(</big><em>maxlen</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLineData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxlen</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">PyObject</td>
</tr>
</tbody>
</table>
<p>Reads up to <tt class="docutils literal"><span class="pre">maxSize</span></tt> characters into <tt class="docutils literal"><span class="pre">data</span></tt> and returns the number of characters read.</p>
<p>This function is called by <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt></a> , and provides its base implementation, using <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.getChar" title="PySide.QtCore.PySide.QtCore.QIODevice.getChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.getChar()</span></tt></a> . Buffered devices can improve the performance of <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt></a> by reimplementing this function.</p>
<p><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLine" title="PySide.QtCore.PySide.QtCore.QIODevice.readLine"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLine()</span></tt></a> appends a &#8216;0&#8217; byte to <tt class="docutils literal"><span class="pre">data</span></tt> ; <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readLineData" title="PySide.QtCore.PySide.QtCore.QIODevice.readLineData"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readLineData()</span></tt></a> does not need to do this.</p>
<p>If you reimplement this function, be careful to return the correct value: it should return the number of bytes read in this line, including the terminating newline, or 0 if there is no line to be read at this point. If an error occurs, it should return -1 if and only if no bytes were read. Reading past EOF is considered an error.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.readyRead">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">readyRead</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.reset">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.reset" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Seeks to the start of input for random-access devices. Returns true on success; otherwise returns false (for example, if the device is not open).</p>
<p>Note that when using a <a class="reference internal" href="QTextStream.html#PySide.QtCore.QTextStream" title="PySide.QtCore.QTextStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QTextStream</span></tt></a> on a <a class="reference internal" href="QFile.html#PySide.QtCore.QFile" title="PySide.QtCore.QFile"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QFile</span></tt></a> , calling <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.reset" title="PySide.QtCore.PySide.QtCore.QIODevice.reset"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.reset()</span></tt></a> on the <a class="reference internal" href="QFile.html#PySide.QtCore.QFile" title="PySide.QtCore.QFile"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QFile</span></tt></a> will not have the expected result because <a class="reference internal" href="QTextStream.html#PySide.QtCore.QTextStream" title="PySide.QtCore.QTextStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QTextStream</span></tt></a> buffers the file. Use the <a class="reference internal" href="QTextStream.html#PySide.QtCore.PySide.QtCore.QTextStream.seek" title="PySide.QtCore.PySide.QtCore.QTextStream.seek"><tt class="xref py py-meth docutils literal"><span class="pre">QTextStream.seek()</span></tt></a> function instead.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.seek" title="PySide.QtCore.PySide.QtCore.QIODevice.seek"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.seek()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.seek">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">seek</tt><big>(</big><em>pos</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.seek" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pos</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>For random-access devices, this function sets the current position to <tt class="docutils literal"><span class="pre">pos</span></tt> , returning true on success, or false if an error occurred. For sequential devices, the default behavior is to do nothing and return false.</p>
<p>When subclassing <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> , you must call <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.seek" title="PySide.QtCore.PySide.QtCore.QIODevice.seek"><tt class="xref py py-meth docutils literal"><span class="pre">QIODevice.seek()</span></tt></a> at the start of your function to ensure integrity with <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> &#8216;s built-in buffer. The base implementation always returns true.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.pos" title="PySide.QtCore.PySide.QtCore.QIODevice.pos"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.pos()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isSequential()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.setErrorString">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">setErrorString</tt><big>(</big><em>errorString</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.setErrorString" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>errorString</strong> &#8211; unicode</td>
</tr>
</tbody>
</table>
<p>Sets the human readable description of the last device error that occurred to <tt class="docutils literal"><span class="pre">str</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.errorString" title="PySide.QtCore.PySide.QtCore.QIODevice.errorString"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.errorString()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">setOpenMode</tt><big>(</big><em>openMode</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>openMode</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice.OpenMode</span></tt></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.setTextModeEnabled">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">setTextModeEnabled</tt><big>(</big><em>enabled</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.setTextModeEnabled" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>enabled</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>If <tt class="docutils literal"><span class="pre">enabled</span></tt> is true, this function sets the <tt class="xref py py-attr docutils literal"><span class="pre">Text</span></tt> flag on the device; otherwise the <tt class="xref py py-attr docutils literal"><span class="pre">Text</span></tt> flag is removed. This feature is useful for classes that provide custom end-of-line handling on a <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> .</p>
<p>The IO device should be opened before calling this function.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isTextModeEnabled" title="PySide.QtCore.PySide.QtCore.QIODevice.isTextModeEnabled"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isTextModeEnabled()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.open" title="PySide.QtCore.PySide.QtCore.QIODevice.open"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.open()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode" title="PySide.QtCore.PySide.QtCore.QIODevice.setOpenMode"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.setOpenMode()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.size">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">size</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>For open random-access devices, this function returns the size of the device. For open sequential devices, <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesAvailable"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesAvailable()</span></tt></a> is returned.</p>
<p>If the device is closed, the size returned will not reflect the actual size of the device.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.isSequential" title="PySide.QtCore.PySide.QtCore.QIODevice.isSequential"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.isSequential()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.pos" title="PySide.QtCore.PySide.QtCore.QIODevice.pos"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.pos()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.ungetChar">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">ungetChar</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.ungetChar" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>c</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.char</span></tt></td>
</tr>
</tbody>
</table>
<p>Puts the character <tt class="docutils literal"><span class="pre">c</span></tt> back into the device, and decrements the current position unless the position is 0. This function is usually called to &#8220;undo&#8221; a <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.getChar" title="PySide.QtCore.PySide.QtCore.QIODevice.getChar"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.getChar()</span></tt></a> operation, such as when writing a backtracking parser.</p>
<p>If <tt class="docutils literal"><span class="pre">c</span></tt> was not previously read from the device, the behavior is undefined.</p>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">waitForBytesWritten</tt><big>(</big><em>msecs</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msecs</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>For buffered devices, this function waits until a payload of buffered written data has been written to the device and the <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesWritten()</span></tt></a> signal has been emitted, or until <tt class="docutils literal"><span class="pre">msecs</span></tt> milliseconds have passed. If msecs is -1, this function will not time out. For unbuffered devices, it returns immediately.</p>
<p>Returns true if a payload of data was written to the device; otherwise returns false (i.e. if the operation timed out, or if an error occurred).</p>
<p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</p>
<p>If called from within a slot connected to the <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesWritten()</span></tt></a> signal, <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.bytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.bytesWritten()</span></tt></a> will not be reemitted.</p>
<p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns false.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Calling this function from the main (GUI) thread might cause your user interface to freeze.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.waitForReadyRead()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">waitForReadyRead</tt><big>(</big><em>msecs</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForReadyRead" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>msecs</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Blocks until new data is available for reading and the <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a> signal has been emitted, or until <tt class="docutils literal"><span class="pre">msecs</span></tt> milliseconds have passed. If msecs is -1, this function will not time out.</p>
<p>Returns true if new data is available for reading; otherwise returns false (if the operation timed out or if an error occurred).</p>
<p>This function can operate without an event loop. It is useful when writing non-GUI applications and when performing I/O operations in a non-GUI thread.</p>
<p>If called from within a slot connected to the <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a> signal, <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.readyRead" title="PySide.QtCore.PySide.QtCore.QIODevice.readyRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.readyRead()</span></tt></a> will not be reemitted.</p>
<p>Reimplement this function to provide a blocking API for a custom device. The default implementation does nothing, and returns false.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Calling this function from the main (GUI) thread might cause your user interface to freeze.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten" title="PySide.QtCore.PySide.QtCore.QIODevice.waitForBytesWritten"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.waitForBytesWritten()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.write">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">write</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.write" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> &#8211; <a class="reference internal" href="QByteArray.html#PySide.QtCore.QByteArray" title="PySide.QtCore.QByteArray"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QByteArray</span></tt></a></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Writes the content of <tt class="docutils literal"><span class="pre">byteArray</span></tt> to the device. Returns the number of bytes that were actually written, or -1 if an error occurred.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.writeData" title="PySide.QtCore.PySide.QtCore.QIODevice.writeData"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.writeData()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QIODevice.writeData">
<tt class="descclassname">PySide.QtCore.QIODevice.</tt><tt class="descname">writeData</tt><big>(</big><em>data</em>, <em>len</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QIODevice.writeData" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> &#8211; str</li>
<li><strong>len</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.qint64</span></tt></p>
</td>
</tr>
</tbody>
</table>
<p>Writes up to <tt class="docutils literal"><span class="pre">maxSize</span></tt> bytes from <tt class="docutils literal"><span class="pre">data</span></tt> to the device. Returns the number of bytes written, or -1 if an error occurred.</p>
<p>This function is called by <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> . Reimplement this function when creating a subclass of <a class="reference internal" href="#PySide.QtCore.QIODevice" title="PySide.QtCore.QIODevice"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QIODevice</span></tt></a> .</p>
<p>When reimplementing this function it is important that this function writes all the data available before returning. This is required in order for <a class="reference internal" href="QDataStream.html#PySide.QtCore.QDataStream" title="PySide.QtCore.QDataStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QDataStream</span></tt></a> to be able to operate on the class. <a class="reference internal" href="QDataStream.html#PySide.QtCore.QDataStream" title="PySide.QtCore.QDataStream"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QDataStream</span></tt></a> assumes all the information was written and therefore does not retry writing if there was a problem.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.read" title="PySide.QtCore.PySide.QtCore.QIODevice.read"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.read()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QIODevice.write" title="PySide.QtCore.PySide.QtCore.QIODevice.write"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QIODevice.write()</span></tt></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>