<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>QReadWriteLock &mdash; PySide 1.2.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pysidedocs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="PySide 1.2.1 documentation" href="../../index.html" />
    <link rel="up" title="PySide.QtCore" href="index.html" />
    <link rel="next" title="QMutexLocker" href="QMutexLocker.html" />
    <link rel="prev" title="QReadLocker" href="QReadLocker.html" /> 
  </head>
  <body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="../../_static/pysidelogo.png" width="199" height="102" /></a></div>
        <div class="related">
            <ul>
                <li><a href="../../index.html">PySide 1.2.1 documentation</a></li>
                <li> &raquo; <a href="../../modules.html" >PySide modules</a></li>
                <li> &raquo; <a href="index.html" accesskey="U">PySide.QtCore</a></li> 
            </ul>
        </div>
    </div>
</div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">QReadWriteLock</a><ul>
<li><a class="reference internal" href="#synopsis">Synopsis</a><ul>
<li><a class="reference internal" href="#functions">Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#detailed-description">Detailed Description</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="QReadLocker.html"
                        title="previous chapter">QReadLocker</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="QMutexLocker.html"
                        title="next chapter">QMutexLocker</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" id="q" size="18" />
      <input type="submit" value="Go" id="search_button" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-PySide.QtCore"></span><div class="section" id="qreadwritelock">
<span id="id1"></span><h1>QReadWriteLock<a class="headerlink" href="#qreadwritelock" title="Permalink to this headline">¶</a></h1>
<div class="section" id="synopsis">
<h2>Synopsis<a class="headerlink" href="#synopsis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">lockForRead</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">lockForWrite</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">tryLockForRead</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">tryLockForRead</span></tt></a> (timeout)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">tryLockForWrite</span></tt></a> ()</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">tryLockForWrite</span></tt></a> (timeout)</li>
<li>def <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">unlock</span></tt></a> ()</li>
</ul>
</div>
</div>
<div class="section" id="detailed-description">
<h2>Detailed Description<a class="headerlink" href="#detailed-description" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> class provides read-write locking.</p>
<p>A read-write lock is a synchronization tool for protecting resources that can be accessed for reading and writing. This type of lock is useful if you want to allow multiple threads to have simultaneous read-only access, but as soon as one thread wants to write to the resource, all other threads must be blocked until the writing is complete.</p>
<p>In many cases, <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> is a direct competitor to <a class="reference internal" href="QMutex.html#PySide.QtCore.QMutex" title="PySide.QtCore.QMutex"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QMutex</span></tt></a> . <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> is a good choice if there are many concurrent reads and writing occurs infrequently.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">lock</span> <span class="o">=</span> <span class="n">QReadWriteLock</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">ReaderThread</span><span class="p">:</span>
    <span class="c"># ...</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
        <span class="c"># ...</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">lockForRead</span><span class="p">()</span>
        <span class="n">read_file</span><span class="p">()</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
        <span class="c"># ...</span>

<span class="k">class</span> <span class="nc">WriterThread</span><span class="p">:</span>
    <span class="c">#...</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
        <span class="c"># ...</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">lockForWrite</span><span class="p">()</span>
        <span class="n">write_file</span><span class="p">()</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
        <span class="c"># ...</span>
</pre></div>
</div>
<p>To ensure that writers aren&#8217;t blocked forever by readers, readers attempting to obtain a lock will not succeed if there is a blocked writer waiting for access, even if the lock is currently only accessed by other readers. Also, if the lock is accessed by a writer and another writer comes in, that writer will have priority over any readers that might also be waiting.</p>
<p>Like <a class="reference internal" href="QMutex.html#PySide.QtCore.QMutex" title="PySide.QtCore.QMutex"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QMutex</span></tt></a> , a <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> can be recursively locked by the same thread when constructed in <tt class="xref py py-attr docutils literal"><span class="pre">QReadWriteLock.RecursionMode</span></tt> . In such cases, <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a> must be called the same number of times <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a> or <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a> was called. Note that the lock type cannot be changed when trying to lock recursively, i.e. it is not possible to lock for reading in a thread that already has locked for writing (and vice versa).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="QReadLocker.html#PySide.QtCore.QReadLocker" title="PySide.QtCore.QReadLocker"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadLocker</span></tt></a>  <a class="reference internal" href="QWriteLocker.html#PySide.QtCore.QWriteLocker" title="PySide.QtCore.QWriteLocker"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QWriteLocker</span></tt></a>  <a class="reference internal" href="QMutex.html#PySide.QtCore.QMutex" title="PySide.QtCore.QMutex"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QMutex</span></tt></a>  <a class="reference internal" href="QSemaphore.html#PySide.QtCore.QSemaphore" title="PySide.QtCore.QSemaphore"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QSemaphore</span></tt></a></p>
</div>
</div></blockquote>
<dl class="class">
<dt id="PySide.QtCore.QReadWriteLock">
<em class="property">class </em><tt class="descclassname">PySide.QtCore.</tt><tt class="descname">QReadWriteLock</tt><a class="headerlink" href="#PySide.QtCore.QReadWriteLock" title="Permalink to this definition">¶</a></dt>
<dt>
<em class="property">class </em><tt class="descclassname">PySide.QtCore.</tt><tt class="descname">QReadWriteLock</tt><big>(</big><em>recursionMode</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recursionMode</strong> &#8211; <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.RecursionMode" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.RecursionMode"><tt class="xref py py-attr docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.RecursionMode</span></tt></a></td>
</tr>
</tbody>
</table>
<p>Constructs a <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> object in <tt class="xref py py-attr docutils literal"><span class="pre">NonRecursive</span></tt> mode.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a></p>
</div>
<p>Constructs a <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> object in the given <tt class="docutils literal"><span class="pre">recursionMode</span></tt> .</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a>  <tt class="xref py py-attr docutils literal"><span class="pre">QReadWriteLock.RecursionMode</span></tt></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="PySide.QtCore.PySide.QtCore.QReadWriteLock.RecursionMode">
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">RecursionMode</tt><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.RecursionMode" title="Permalink to this definition">¶</a></dt>
<dd><table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Constant</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>QReadWriteLock.Recursive</td>
<td>In this mode, a thread can lock the same <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> multiple times and the mutex won&#8217;t be unlocked until a corresponding number of <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a> calls have been made.</td>
</tr>
<tr class="row-odd"><td>QReadWriteLock.NonRecursive</td>
<td>In this mode, a thread may only lock a <a class="reference internal" href="#PySide.QtCore.QReadWriteLock" title="PySide.QtCore.QReadWriteLock"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock</span></tt></a> once.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.QReadWriteLock()</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead">
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">lockForRead</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks the lock for reading. This function will block the current thread if any thread (including the current) has locked for writing.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.tryLockForRead()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite">
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">lockForWrite</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Locks the lock for writing. This function will block the current thread if another thread has locked for reading or writing.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.tryLockForWrite()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead">
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">tryLockForRead</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Attempts to lock for reading. If the lock was obtained, this function returns true, otherwise it returns false instead of waiting for the lock to become available, i.e. it does not block.</p>
<p>The lock attempt will fail if another thread has locked for writing.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a> before another thread can successfully lock it.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">tryLockForRead</tt><big>(</big><em>timeout</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timeout</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Attempts to lock for reading. This function returns true if the lock was obtained; otherwise it returns false. If another thread has locked for writing, this function will wait for at most <tt class="docutils literal"><span class="pre">timeout</span></tt> milliseconds for the lock to become available.</p>
<p>Note: Passing a negative number as the <tt class="docutils literal"><span class="pre">timeout</span></tt> is equivalent to calling <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a> , i.e. this function will wait forever until lock can be locked for reading when <tt class="docutils literal"><span class="pre">timeout</span></tt> is negative.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a> before another thread can successfully lock it.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite">
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">tryLockForWrite</tt><big>(</big><em>timeout</em><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>timeout</strong> &#8211; <tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.int</span></tt></td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>This is an overloaded function.</p>
<p>Attempts to lock for writing. This function returns true if the lock was obtained; otherwise it returns false. If another thread has locked for reading or writing, this function will wait for at most <tt class="docutils literal"><span class="pre">timeout</span></tt> milliseconds for the lock to become available.</p>
<p>Note: Passing a negative number as the <tt class="docutils literal"><span class="pre">timeout</span></tt> is equivalent to calling <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a> , i.e. this function will wait forever until lock can be locked for writing when <tt class="docutils literal"><span class="pre">timeout</span></tt> is negative.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a> before another thread can successfully lock it.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">tryLockForWrite</tt><big>(</big><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><tt class="xref py py-class docutils literal"><span class="pre">PySide.QtCore.bool</span></tt></td>
</tr>
</tbody>
</table>
<p>Attempts to lock for writing. If the lock was obtained, this function returns true; otherwise, it returns false immediately.</p>
<p>The lock attempt will fail if another thread has locked for reading or writing.</p>
<p>If the lock was obtained, the lock must be unlocked with <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a> before another thread can successfully lock it.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.unlock()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock">
<tt class="descclassname">PySide.QtCore.QReadWriteLock.</tt><tt class="descname">unlock</tt><big>(</big><big>)</big><a class="headerlink" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlocks the lock.</p>
<p>Attempting to unlock a lock that is not locked is an error, and will result in program termination.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.lockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.lockForWrite()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForRead"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.tryLockForRead()</span></tt></a>  <a class="reference internal" href="#PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite" title="PySide.QtCore.PySide.QtCore.QReadWriteLock.tryLockForWrite"><tt class="xref py py-meth docutils literal"><span class="pre">PySide.QtCore.QReadWriteLock.tryLockForWrite()</span></tt></a></p>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.indt.org.br"><img src="../../_static/logo_indt.jpg" alt="Indt" border="0" /></a>
    <a href="http://www.openbossa.org"><img src="../../_static/logo_openbossa.png" alt="Openbossa" border="0" /></a>
    <a href="http://qt.nokia.com/"><img src="../../_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="../../_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>